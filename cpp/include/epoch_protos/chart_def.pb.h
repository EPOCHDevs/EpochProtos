// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chart_def.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chart_5fdef_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chart_5fdef_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chart_5fdef_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chart_5fdef_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chart_5fdef_2eproto;
namespace epoch_proto {
class AxisDef;
struct AxisDefDefaultTypeInternal;
extern AxisDefDefaultTypeInternal _AxisDef_default_instance_;
class Band;
struct BandDefaultTypeInternal;
extern BandDefaultTypeInternal _Band_default_instance_;
class BarDef;
struct BarDefDefaultTypeInternal;
extern BarDefDefaultTypeInternal _BarDef_default_instance_;
class BoxPlotDataPoint;
struct BoxPlotDataPointDefaultTypeInternal;
extern BoxPlotDataPointDefaultTypeInternal _BoxPlotDataPoint_default_instance_;
class BoxPlotDataPointDef;
struct BoxPlotDataPointDefDefaultTypeInternal;
extern BoxPlotDataPointDefDefaultTypeInternal _BoxPlotDataPointDef_default_instance_;
class BoxPlotDef;
struct BoxPlotDefDefaultTypeInternal;
extern BoxPlotDefDefaultTypeInternal _BoxPlotDef_default_instance_;
class BoxPlotOutlier;
struct BoxPlotOutlierDefaultTypeInternal;
extern BoxPlotOutlierDefaultTypeInternal _BoxPlotOutlier_default_instance_;
class Chart;
struct ChartDefaultTypeInternal;
extern ChartDefaultTypeInternal _Chart_default_instance_;
class ChartDef;
struct ChartDefDefaultTypeInternal;
extern ChartDefDefaultTypeInternal _ChartDef_default_instance_;
class HeatMapDef;
struct HeatMapDefDefaultTypeInternal;
extern HeatMapDefDefaultTypeInternal _HeatMapDef_default_instance_;
class HeatMapPoint;
struct HeatMapPointDefaultTypeInternal;
extern HeatMapPointDefaultTypeInternal _HeatMapPoint_default_instance_;
class HistogramDef;
struct HistogramDefDefaultTypeInternal;
extern HistogramDefDefaultTypeInternal _HistogramDef_default_instance_;
class Line;
struct LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class LinesDef;
struct LinesDefDefaultTypeInternal;
extern LinesDefDefaultTypeInternal _LinesDef_default_instance_;
class PieData;
struct PieDataDefaultTypeInternal;
extern PieDataDefaultTypeInternal _PieData_default_instance_;
class PieDataDef;
struct PieDataDefDefaultTypeInternal;
extern PieDataDefDefaultTypeInternal _PieDataDef_default_instance_;
class PieDef;
struct PieDefDefaultTypeInternal;
extern PieDefDefaultTypeInternal _PieDef_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class StraightLineDef;
struct StraightLineDefDefaultTypeInternal;
extern StraightLineDefDefaultTypeInternal _StraightLineDef_default_instance_;
class XRangeDef;
struct XRangeDefDefaultTypeInternal;
extern XRangeDefDefaultTypeInternal _XRangeDef_default_instance_;
class XRangePoint;
struct XRangePointDefaultTypeInternal;
extern XRangePointDefaultTypeInternal _XRangePoint_default_instance_;
}  // namespace epoch_proto
PROTOBUF_NAMESPACE_OPEN
template<> ::epoch_proto::AxisDef* Arena::CreateMaybeMessage<::epoch_proto::AxisDef>(Arena*);
template<> ::epoch_proto::Band* Arena::CreateMaybeMessage<::epoch_proto::Band>(Arena*);
template<> ::epoch_proto::BarDef* Arena::CreateMaybeMessage<::epoch_proto::BarDef>(Arena*);
template<> ::epoch_proto::BoxPlotDataPoint* Arena::CreateMaybeMessage<::epoch_proto::BoxPlotDataPoint>(Arena*);
template<> ::epoch_proto::BoxPlotDataPointDef* Arena::CreateMaybeMessage<::epoch_proto::BoxPlotDataPointDef>(Arena*);
template<> ::epoch_proto::BoxPlotDef* Arena::CreateMaybeMessage<::epoch_proto::BoxPlotDef>(Arena*);
template<> ::epoch_proto::BoxPlotOutlier* Arena::CreateMaybeMessage<::epoch_proto::BoxPlotOutlier>(Arena*);
template<> ::epoch_proto::Chart* Arena::CreateMaybeMessage<::epoch_proto::Chart>(Arena*);
template<> ::epoch_proto::ChartDef* Arena::CreateMaybeMessage<::epoch_proto::ChartDef>(Arena*);
template<> ::epoch_proto::HeatMapDef* Arena::CreateMaybeMessage<::epoch_proto::HeatMapDef>(Arena*);
template<> ::epoch_proto::HeatMapPoint* Arena::CreateMaybeMessage<::epoch_proto::HeatMapPoint>(Arena*);
template<> ::epoch_proto::HistogramDef* Arena::CreateMaybeMessage<::epoch_proto::HistogramDef>(Arena*);
template<> ::epoch_proto::Line* Arena::CreateMaybeMessage<::epoch_proto::Line>(Arena*);
template<> ::epoch_proto::LinesDef* Arena::CreateMaybeMessage<::epoch_proto::LinesDef>(Arena*);
template<> ::epoch_proto::PieData* Arena::CreateMaybeMessage<::epoch_proto::PieData>(Arena*);
template<> ::epoch_proto::PieDataDef* Arena::CreateMaybeMessage<::epoch_proto::PieDataDef>(Arena*);
template<> ::epoch_proto::PieDef* Arena::CreateMaybeMessage<::epoch_proto::PieDef>(Arena*);
template<> ::epoch_proto::Point* Arena::CreateMaybeMessage<::epoch_proto::Point>(Arena*);
template<> ::epoch_proto::StraightLineDef* Arena::CreateMaybeMessage<::epoch_proto::StraightLineDef>(Arena*);
template<> ::epoch_proto::XRangeDef* Arena::CreateMaybeMessage<::epoch_proto::XRangeDef>(Arena*);
template<> ::epoch_proto::XRangePoint* Arena::CreateMaybeMessage<::epoch_proto::XRangePoint>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace epoch_proto {

// ===================================================================

class AxisDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.AxisDef) */ {
 public:
  inline AxisDef() : AxisDef(nullptr) {}
  ~AxisDef() override;
  explicit PROTOBUF_CONSTEXPR AxisDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AxisDef(const AxisDef& from);
  AxisDef(AxisDef&& from) noexcept
    : AxisDef() {
    *this = ::std::move(from);
  }

  inline AxisDef& operator=(const AxisDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline AxisDef& operator=(AxisDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AxisDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const AxisDef* internal_default_instance() {
    return reinterpret_cast<const AxisDef*>(
               &_AxisDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AxisDef& a, AxisDef& b) {
    a.Swap(&b);
  }
  inline void Swap(AxisDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AxisDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AxisDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AxisDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AxisDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AxisDef& from) {
    AxisDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AxisDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.AxisDef";
  }
  protected:
  explicit AxisDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 3,
    kLabelFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string categories = 3;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, size_t size);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();
  private:
  const std::string& _internal_categories(int index) const;
  std::string* _internal_add_categories();
  public:

  // optional string label = 2;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional .epoch_proto.AxisType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::epoch_proto::AxisType type() const;
  void set_type(::epoch_proto::AxisType value);
  private:
  ::epoch_proto::AxisType _internal_type() const;
  void _internal_set_type(::epoch_proto::AxisType value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.AxisDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class ChartDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.ChartDef) */ {
 public:
  inline ChartDef() : ChartDef(nullptr) {}
  ~ChartDef() override;
  explicit PROTOBUF_CONSTEXPR ChartDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartDef(const ChartDef& from);
  ChartDef(ChartDef&& from) noexcept
    : ChartDef() {
    *this = ::std::move(from);
  }

  inline ChartDef& operator=(const ChartDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartDef& operator=(ChartDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartDef* internal_default_instance() {
    return reinterpret_cast<const ChartDef*>(
               &_ChartDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChartDef& a, ChartDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartDef& from) {
    ChartDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.ChartDef";
  }
  protected:
  explicit ChartDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kCategoryFieldNumber = 4,
    kYAxisFieldNumber = 5,
    kXAxisFieldNumber = 6,
    kTypeFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string category = 4;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // optional .epoch_proto.AxisDef y_axis = 5;
  bool has_y_axis() const;
  private:
  bool _internal_has_y_axis() const;
  public:
  void clear_y_axis();
  const ::epoch_proto::AxisDef& y_axis() const;
  PROTOBUF_NODISCARD ::epoch_proto::AxisDef* release_y_axis();
  ::epoch_proto::AxisDef* mutable_y_axis();
  void set_allocated_y_axis(::epoch_proto::AxisDef* y_axis);
  private:
  const ::epoch_proto::AxisDef& _internal_y_axis() const;
  ::epoch_proto::AxisDef* _internal_mutable_y_axis();
  public:
  void unsafe_arena_set_allocated_y_axis(
      ::epoch_proto::AxisDef* y_axis);
  ::epoch_proto::AxisDef* unsafe_arena_release_y_axis();

  // optional .epoch_proto.AxisDef x_axis = 6;
  bool has_x_axis() const;
  private:
  bool _internal_has_x_axis() const;
  public:
  void clear_x_axis();
  const ::epoch_proto::AxisDef& x_axis() const;
  PROTOBUF_NODISCARD ::epoch_proto::AxisDef* release_x_axis();
  ::epoch_proto::AxisDef* mutable_x_axis();
  void set_allocated_x_axis(::epoch_proto::AxisDef* x_axis);
  private:
  const ::epoch_proto::AxisDef& _internal_x_axis() const;
  ::epoch_proto::AxisDef* _internal_mutable_x_axis();
  public:
  void unsafe_arena_set_allocated_x_axis(
      ::epoch_proto::AxisDef* x_axis);
  ::epoch_proto::AxisDef* unsafe_arena_release_x_axis();

  // .epoch_proto.EpochFolioDashboardWidget type = 3;
  void clear_type();
  ::epoch_proto::EpochFolioDashboardWidget type() const;
  void set_type(::epoch_proto::EpochFolioDashboardWidget value);
  private:
  ::epoch_proto::EpochFolioDashboardWidget _internal_type() const;
  void _internal_set_type(::epoch_proto::EpochFolioDashboardWidget value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.ChartDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
    ::epoch_proto::AxisDef* y_axis_;
    ::epoch_proto::AxisDef* x_axis_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class StraightLineDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.StraightLineDef) */ {
 public:
  inline StraightLineDef() : StraightLineDef(nullptr) {}
  ~StraightLineDef() override;
  explicit PROTOBUF_CONSTEXPR StraightLineDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StraightLineDef(const StraightLineDef& from);
  StraightLineDef(StraightLineDef&& from) noexcept
    : StraightLineDef() {
    *this = ::std::move(from);
  }

  inline StraightLineDef& operator=(const StraightLineDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline StraightLineDef& operator=(StraightLineDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StraightLineDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const StraightLineDef* internal_default_instance() {
    return reinterpret_cast<const StraightLineDef*>(
               &_StraightLineDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StraightLineDef& a, StraightLineDef& b) {
    a.Swap(&b);
  }
  inline void Swap(StraightLineDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StraightLineDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StraightLineDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StraightLineDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StraightLineDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StraightLineDef& from) {
    StraightLineDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StraightLineDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.StraightLineDef";
  }
  protected:
  explicit StraightLineDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kValueFieldNumber = 2,
    kVerticalFieldNumber = 3,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // bool vertical = 3;
  void clear_vertical();
  bool vertical() const;
  void set_vertical(bool value);
  private:
  bool _internal_vertical() const;
  void _internal_set_vertical(bool value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.StraightLineDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    double value_;
    bool vertical_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Band final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.Band) */ {
 public:
  inline Band() : Band(nullptr) {}
  ~Band() override;
  explicit PROTOBUF_CONSTEXPR Band(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Band(const Band& from);
  Band(Band&& from) noexcept
    : Band() {
    *this = ::std::move(from);
  }

  inline Band& operator=(const Band& from) {
    CopyFrom(from);
    return *this;
  }
  inline Band& operator=(Band&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Band& default_instance() {
    return *internal_default_instance();
  }
  static inline const Band* internal_default_instance() {
    return reinterpret_cast<const Band*>(
               &_Band_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Band& a, Band& b) {
    a.Swap(&b);
  }
  inline void Swap(Band* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Band* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Band* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Band>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Band& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Band& from) {
    Band::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Band* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.Band";
  }
  protected:
  explicit Band(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // .epoch_proto.Scalar from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::epoch_proto::Scalar& from() const;
  PROTOBUF_NODISCARD ::epoch_proto::Scalar* release_from();
  ::epoch_proto::Scalar* mutable_from();
  void set_allocated_from(::epoch_proto::Scalar* from);
  private:
  const ::epoch_proto::Scalar& _internal_from() const;
  ::epoch_proto::Scalar* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::epoch_proto::Scalar* from);
  ::epoch_proto::Scalar* unsafe_arena_release_from();

  // .epoch_proto.Scalar to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::epoch_proto::Scalar& to() const;
  PROTOBUF_NODISCARD ::epoch_proto::Scalar* release_to();
  ::epoch_proto::Scalar* mutable_to();
  void set_allocated_to(::epoch_proto::Scalar* to);
  private:
  const ::epoch_proto::Scalar& _internal_to() const;
  ::epoch_proto::Scalar* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::epoch_proto::Scalar* to);
  ::epoch_proto::Scalar* unsafe_arena_release_to();

  // @@protoc_insertion_point(class_scope:epoch_proto.Band)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::epoch_proto::Scalar* from_;
    ::epoch_proto::Scalar* to_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int64 x = 1;
  void clear_x();
  int64_t x() const;
  void set_x(int64_t value);
  private:
  int64_t _internal_x() const;
  void _internal_set_x(int64_t value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t x_;
    double y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Line final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.Line) */ {
 public:
  inline Line() : Line(nullptr) {}
  ~Line() override;
  explicit PROTOBUF_CONSTEXPR Line(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Line(const Line& from);
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Line& default_instance() {
    return *internal_default_instance();
  }
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Line* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Line* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Line& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Line& from) {
    Line::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.Line";
  }
  protected:
  explicit Line(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kNameFieldNumber = 2,
    kDashStyleFieldNumber = 3,
    kLineWidthFieldNumber = 4,
  };
  // repeated .epoch_proto.Point data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::epoch_proto::Point* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Point >*
      mutable_data();
  private:
  const ::epoch_proto::Point& _internal_data(int index) const;
  ::epoch_proto::Point* _internal_add_data();
  public:
  const ::epoch_proto::Point& data(int index) const;
  ::epoch_proto::Point* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Point >&
      data() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string dash_style = 3;
  bool has_dash_style() const;
  private:
  bool _internal_has_dash_style() const;
  public:
  void clear_dash_style();
  const std::string& dash_style() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dash_style(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dash_style();
  PROTOBUF_NODISCARD std::string* release_dash_style();
  void set_allocated_dash_style(std::string* dash_style);
  private:
  const std::string& _internal_dash_style() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dash_style(const std::string& value);
  std::string* _internal_mutable_dash_style();
  public:

  // optional uint32 line_width = 4;
  bool has_line_width() const;
  private:
  bool _internal_has_line_width() const;
  public:
  void clear_line_width();
  uint32_t line_width() const;
  void set_line_width(uint32_t value);
  private:
  uint32_t _internal_line_width() const;
  void _internal_set_line_width(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.Line)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Point > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dash_style_;
    uint32_t line_width_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class LinesDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.LinesDef) */ {
 public:
  inline LinesDef() : LinesDef(nullptr) {}
  ~LinesDef() override;
  explicit PROTOBUF_CONSTEXPR LinesDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinesDef(const LinesDef& from);
  LinesDef(LinesDef&& from) noexcept
    : LinesDef() {
    *this = ::std::move(from);
  }

  inline LinesDef& operator=(const LinesDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinesDef& operator=(LinesDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinesDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinesDef* internal_default_instance() {
    return reinterpret_cast<const LinesDef*>(
               &_LinesDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LinesDef& a, LinesDef& b) {
    a.Swap(&b);
  }
  inline void Swap(LinesDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinesDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinesDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinesDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinesDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LinesDef& from) {
    LinesDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinesDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.LinesDef";
  }
  protected:
  explicit LinesDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinesFieldNumber = 2,
    kStraightLinesFieldNumber = 3,
    kYPlotBandsFieldNumber = 4,
    kXPlotBandsFieldNumber = 5,
    kChartDefFieldNumber = 1,
    kOverlayFieldNumber = 6,
    kStackedFieldNumber = 7,
  };
  // repeated .epoch_proto.Line lines = 2;
  int lines_size() const;
  private:
  int _internal_lines_size() const;
  public:
  void clear_lines();
  ::epoch_proto::Line* mutable_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Line >*
      mutable_lines();
  private:
  const ::epoch_proto::Line& _internal_lines(int index) const;
  ::epoch_proto::Line* _internal_add_lines();
  public:
  const ::epoch_proto::Line& lines(int index) const;
  ::epoch_proto::Line* add_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Line >&
      lines() const;

  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  int straight_lines_size() const;
  private:
  int _internal_straight_lines_size() const;
  public:
  void clear_straight_lines();
  ::epoch_proto::StraightLineDef* mutable_straight_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >*
      mutable_straight_lines();
  private:
  const ::epoch_proto::StraightLineDef& _internal_straight_lines(int index) const;
  ::epoch_proto::StraightLineDef* _internal_add_straight_lines();
  public:
  const ::epoch_proto::StraightLineDef& straight_lines(int index) const;
  ::epoch_proto::StraightLineDef* add_straight_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >&
      straight_lines() const;

  // repeated .epoch_proto.Band y_plot_bands = 4;
  int y_plot_bands_size() const;
  private:
  int _internal_y_plot_bands_size() const;
  public:
  void clear_y_plot_bands();
  ::epoch_proto::Band* mutable_y_plot_bands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >*
      mutable_y_plot_bands();
  private:
  const ::epoch_proto::Band& _internal_y_plot_bands(int index) const;
  ::epoch_proto::Band* _internal_add_y_plot_bands();
  public:
  const ::epoch_proto::Band& y_plot_bands(int index) const;
  ::epoch_proto::Band* add_y_plot_bands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >&
      y_plot_bands() const;

  // repeated .epoch_proto.Band x_plot_bands = 5;
  int x_plot_bands_size() const;
  private:
  int _internal_x_plot_bands_size() const;
  public:
  void clear_x_plot_bands();
  ::epoch_proto::Band* mutable_x_plot_bands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >*
      mutable_x_plot_bands();
  private:
  const ::epoch_proto::Band& _internal_x_plot_bands(int index) const;
  ::epoch_proto::Band* _internal_add_x_plot_bands();
  public:
  const ::epoch_proto::Band& x_plot_bands(int index) const;
  ::epoch_proto::Band* add_x_plot_bands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >&
      x_plot_bands() const;

  // .epoch_proto.ChartDef chart_def = 1;
  bool has_chart_def() const;
  private:
  bool _internal_has_chart_def() const;
  public:
  void clear_chart_def();
  const ::epoch_proto::ChartDef& chart_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::ChartDef* release_chart_def();
  ::epoch_proto::ChartDef* mutable_chart_def();
  void set_allocated_chart_def(::epoch_proto::ChartDef* chart_def);
  private:
  const ::epoch_proto::ChartDef& _internal_chart_def() const;
  ::epoch_proto::ChartDef* _internal_mutable_chart_def();
  public:
  void unsafe_arena_set_allocated_chart_def(
      ::epoch_proto::ChartDef* chart_def);
  ::epoch_proto::ChartDef* unsafe_arena_release_chart_def();

  // optional .epoch_proto.Line overlay = 6;
  bool has_overlay() const;
  private:
  bool _internal_has_overlay() const;
  public:
  void clear_overlay();
  const ::epoch_proto::Line& overlay() const;
  PROTOBUF_NODISCARD ::epoch_proto::Line* release_overlay();
  ::epoch_proto::Line* mutable_overlay();
  void set_allocated_overlay(::epoch_proto::Line* overlay);
  private:
  const ::epoch_proto::Line& _internal_overlay() const;
  ::epoch_proto::Line* _internal_mutable_overlay();
  public:
  void unsafe_arena_set_allocated_overlay(
      ::epoch_proto::Line* overlay);
  ::epoch_proto::Line* unsafe_arena_release_overlay();

  // bool stacked = 7;
  void clear_stacked();
  bool stacked() const;
  void set_stacked(bool value);
  private:
  bool _internal_stacked() const;
  void _internal_set_stacked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.LinesDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Line > lines_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef > straight_lines_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band > y_plot_bands_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band > x_plot_bands_;
    ::epoch_proto::ChartDef* chart_def_;
    ::epoch_proto::Line* overlay_;
    bool stacked_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class HeatMapPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.HeatMapPoint) */ {
 public:
  inline HeatMapPoint() : HeatMapPoint(nullptr) {}
  ~HeatMapPoint() override;
  explicit PROTOBUF_CONSTEXPR HeatMapPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeatMapPoint(const HeatMapPoint& from);
  HeatMapPoint(HeatMapPoint&& from) noexcept
    : HeatMapPoint() {
    *this = ::std::move(from);
  }

  inline HeatMapPoint& operator=(const HeatMapPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeatMapPoint& operator=(HeatMapPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeatMapPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeatMapPoint* internal_default_instance() {
    return reinterpret_cast<const HeatMapPoint*>(
               &_HeatMapPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HeatMapPoint& a, HeatMapPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(HeatMapPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeatMapPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeatMapPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeatMapPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeatMapPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeatMapPoint& from) {
    HeatMapPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeatMapPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.HeatMapPoint";
  }
  protected:
  explicit HeatMapPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // uint64 x = 1;
  void clear_x();
  uint64_t x() const;
  void set_x(uint64_t value);
  private:
  uint64_t _internal_x() const;
  void _internal_set_x(uint64_t value);
  public:

  // uint64 y = 2;
  void clear_y();
  uint64_t y() const;
  void set_y(uint64_t value);
  private:
  uint64_t _internal_y() const;
  void _internal_set_y(uint64_t value);
  public:

  // double value = 3;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.HeatMapPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t x_;
    uint64_t y_;
    double value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class HeatMapDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.HeatMapDef) */ {
 public:
  inline HeatMapDef() : HeatMapDef(nullptr) {}
  ~HeatMapDef() override;
  explicit PROTOBUF_CONSTEXPR HeatMapDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeatMapDef(const HeatMapDef& from);
  HeatMapDef(HeatMapDef&& from) noexcept
    : HeatMapDef() {
    *this = ::std::move(from);
  }

  inline HeatMapDef& operator=(const HeatMapDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeatMapDef& operator=(HeatMapDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeatMapDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeatMapDef* internal_default_instance() {
    return reinterpret_cast<const HeatMapDef*>(
               &_HeatMapDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HeatMapDef& a, HeatMapDef& b) {
    a.Swap(&b);
  }
  inline void Swap(HeatMapDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeatMapDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeatMapDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeatMapDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeatMapDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeatMapDef& from) {
    HeatMapDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeatMapDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.HeatMapDef";
  }
  protected:
  explicit HeatMapDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kChartDefFieldNumber = 1,
  };
  // repeated .epoch_proto.HeatMapPoint points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::epoch_proto::HeatMapPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::HeatMapPoint >*
      mutable_points();
  private:
  const ::epoch_proto::HeatMapPoint& _internal_points(int index) const;
  ::epoch_proto::HeatMapPoint* _internal_add_points();
  public:
  const ::epoch_proto::HeatMapPoint& points(int index) const;
  ::epoch_proto::HeatMapPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::HeatMapPoint >&
      points() const;

  // .epoch_proto.ChartDef chart_def = 1;
  bool has_chart_def() const;
  private:
  bool _internal_has_chart_def() const;
  public:
  void clear_chart_def();
  const ::epoch_proto::ChartDef& chart_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::ChartDef* release_chart_def();
  ::epoch_proto::ChartDef* mutable_chart_def();
  void set_allocated_chart_def(::epoch_proto::ChartDef* chart_def);
  private:
  const ::epoch_proto::ChartDef& _internal_chart_def() const;
  ::epoch_proto::ChartDef* _internal_mutable_chart_def();
  public:
  void unsafe_arena_set_allocated_chart_def(
      ::epoch_proto::ChartDef* chart_def);
  ::epoch_proto::ChartDef* unsafe_arena_release_chart_def();

  // @@protoc_insertion_point(class_scope:epoch_proto.HeatMapDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::HeatMapPoint > points_;
    ::epoch_proto::ChartDef* chart_def_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BarDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.BarDef) */ {
 public:
  inline BarDef() : BarDef(nullptr) {}
  ~BarDef() override;
  explicit PROTOBUF_CONSTEXPR BarDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BarDef(const BarDef& from);
  BarDef(BarDef&& from) noexcept
    : BarDef() {
    *this = ::std::move(from);
  }

  inline BarDef& operator=(const BarDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarDef& operator=(BarDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BarDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const BarDef* internal_default_instance() {
    return reinterpret_cast<const BarDef*>(
               &_BarDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BarDef& a, BarDef& b) {
    a.Swap(&b);
  }
  inline void Swap(BarDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BarDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BarDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BarDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BarDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BarDef& from) {
    BarDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.BarDef";
  }
  protected:
  explicit BarDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStraightLinesFieldNumber = 3,
    kChartDefFieldNumber = 1,
    kDataFieldNumber = 2,
    kBarWidthFieldNumber = 4,
  };
  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  int straight_lines_size() const;
  private:
  int _internal_straight_lines_size() const;
  public:
  void clear_straight_lines();
  ::epoch_proto::StraightLineDef* mutable_straight_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >*
      mutable_straight_lines();
  private:
  const ::epoch_proto::StraightLineDef& _internal_straight_lines(int index) const;
  ::epoch_proto::StraightLineDef* _internal_add_straight_lines();
  public:
  const ::epoch_proto::StraightLineDef& straight_lines(int index) const;
  ::epoch_proto::StraightLineDef* add_straight_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >&
      straight_lines() const;

  // .epoch_proto.ChartDef chart_def = 1;
  bool has_chart_def() const;
  private:
  bool _internal_has_chart_def() const;
  public:
  void clear_chart_def();
  const ::epoch_proto::ChartDef& chart_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::ChartDef* release_chart_def();
  ::epoch_proto::ChartDef* mutable_chart_def();
  void set_allocated_chart_def(::epoch_proto::ChartDef* chart_def);
  private:
  const ::epoch_proto::ChartDef& _internal_chart_def() const;
  ::epoch_proto::ChartDef* _internal_mutable_chart_def();
  public:
  void unsafe_arena_set_allocated_chart_def(
      ::epoch_proto::ChartDef* chart_def);
  ::epoch_proto::ChartDef* unsafe_arena_release_chart_def();

  // .epoch_proto.Array data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::epoch_proto::Array& data() const;
  PROTOBUF_NODISCARD ::epoch_proto::Array* release_data();
  ::epoch_proto::Array* mutable_data();
  void set_allocated_data(::epoch_proto::Array* data);
  private:
  const ::epoch_proto::Array& _internal_data() const;
  ::epoch_proto::Array* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::epoch_proto::Array* data);
  ::epoch_proto::Array* unsafe_arena_release_data();

  // optional uint32 bar_width = 4;
  bool has_bar_width() const;
  private:
  bool _internal_has_bar_width() const;
  public:
  void clear_bar_width();
  uint32_t bar_width() const;
  void set_bar_width(uint32_t value);
  private:
  uint32_t _internal_bar_width() const;
  void _internal_set_bar_width(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.BarDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef > straight_lines_;
    ::epoch_proto::ChartDef* chart_def_;
    ::epoch_proto::Array* data_;
    uint32_t bar_width_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class HistogramDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.HistogramDef) */ {
 public:
  inline HistogramDef() : HistogramDef(nullptr) {}
  ~HistogramDef() override;
  explicit PROTOBUF_CONSTEXPR HistogramDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistogramDef(const HistogramDef& from);
  HistogramDef(HistogramDef&& from) noexcept
    : HistogramDef() {
    *this = ::std::move(from);
  }

  inline HistogramDef& operator=(const HistogramDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistogramDef& operator=(HistogramDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistogramDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistogramDef* internal_default_instance() {
    return reinterpret_cast<const HistogramDef*>(
               &_HistogramDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HistogramDef& a, HistogramDef& b) {
    a.Swap(&b);
  }
  inline void Swap(HistogramDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistogramDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistogramDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistogramDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistogramDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistogramDef& from) {
    HistogramDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistogramDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.HistogramDef";
  }
  protected:
  explicit HistogramDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStraightLinesFieldNumber = 3,
    kChartDefFieldNumber = 1,
    kDataFieldNumber = 2,
    kBinsCountFieldNumber = 4,
  };
  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  int straight_lines_size() const;
  private:
  int _internal_straight_lines_size() const;
  public:
  void clear_straight_lines();
  ::epoch_proto::StraightLineDef* mutable_straight_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >*
      mutable_straight_lines();
  private:
  const ::epoch_proto::StraightLineDef& _internal_straight_lines(int index) const;
  ::epoch_proto::StraightLineDef* _internal_add_straight_lines();
  public:
  const ::epoch_proto::StraightLineDef& straight_lines(int index) const;
  ::epoch_proto::StraightLineDef* add_straight_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >&
      straight_lines() const;

  // .epoch_proto.ChartDef chart_def = 1;
  bool has_chart_def() const;
  private:
  bool _internal_has_chart_def() const;
  public:
  void clear_chart_def();
  const ::epoch_proto::ChartDef& chart_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::ChartDef* release_chart_def();
  ::epoch_proto::ChartDef* mutable_chart_def();
  void set_allocated_chart_def(::epoch_proto::ChartDef* chart_def);
  private:
  const ::epoch_proto::ChartDef& _internal_chart_def() const;
  ::epoch_proto::ChartDef* _internal_mutable_chart_def();
  public:
  void unsafe_arena_set_allocated_chart_def(
      ::epoch_proto::ChartDef* chart_def);
  ::epoch_proto::ChartDef* unsafe_arena_release_chart_def();

  // .epoch_proto.Array data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::epoch_proto::Array& data() const;
  PROTOBUF_NODISCARD ::epoch_proto::Array* release_data();
  ::epoch_proto::Array* mutable_data();
  void set_allocated_data(::epoch_proto::Array* data);
  private:
  const ::epoch_proto::Array& _internal_data() const;
  ::epoch_proto::Array* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::epoch_proto::Array* data);
  ::epoch_proto::Array* unsafe_arena_release_data();

  // optional uint32 bins_count = 4;
  bool has_bins_count() const;
  private:
  bool _internal_has_bins_count() const;
  public:
  void clear_bins_count();
  uint32_t bins_count() const;
  void set_bins_count(uint32_t value);
  private:
  uint32_t _internal_bins_count() const;
  void _internal_set_bins_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.HistogramDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef > straight_lines_;
    ::epoch_proto::ChartDef* chart_def_;
    ::epoch_proto::Array* data_;
    uint32_t bins_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BoxPlotDataPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.BoxPlotDataPoint) */ {
 public:
  inline BoxPlotDataPoint() : BoxPlotDataPoint(nullptr) {}
  ~BoxPlotDataPoint() override;
  explicit PROTOBUF_CONSTEXPR BoxPlotDataPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxPlotDataPoint(const BoxPlotDataPoint& from);
  BoxPlotDataPoint(BoxPlotDataPoint&& from) noexcept
    : BoxPlotDataPoint() {
    *this = ::std::move(from);
  }

  inline BoxPlotDataPoint& operator=(const BoxPlotDataPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxPlotDataPoint& operator=(BoxPlotDataPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxPlotDataPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxPlotDataPoint* internal_default_instance() {
    return reinterpret_cast<const BoxPlotDataPoint*>(
               &_BoxPlotDataPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BoxPlotDataPoint& a, BoxPlotDataPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxPlotDataPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxPlotDataPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoxPlotDataPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoxPlotDataPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoxPlotDataPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoxPlotDataPoint& from) {
    BoxPlotDataPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxPlotDataPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.BoxPlotDataPoint";
  }
  protected:
  explicit BoxPlotDataPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowFieldNumber = 1,
    kQ1FieldNumber = 2,
    kMedianFieldNumber = 3,
    kQ3FieldNumber = 4,
    kHighFieldNumber = 5,
  };
  // double low = 1;
  void clear_low();
  double low() const;
  void set_low(double value);
  private:
  double _internal_low() const;
  void _internal_set_low(double value);
  public:

  // double q1 = 2;
  void clear_q1();
  double q1() const;
  void set_q1(double value);
  private:
  double _internal_q1() const;
  void _internal_set_q1(double value);
  public:

  // double median = 3;
  void clear_median();
  double median() const;
  void set_median(double value);
  private:
  double _internal_median() const;
  void _internal_set_median(double value);
  public:

  // double q3 = 4;
  void clear_q3();
  double q3() const;
  void set_q3(double value);
  private:
  double _internal_q3() const;
  void _internal_set_q3(double value);
  public:

  // double high = 5;
  void clear_high();
  double high() const;
  void set_high(double value);
  private:
  double _internal_high() const;
  void _internal_set_high(double value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.BoxPlotDataPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double low_;
    double q1_;
    double median_;
    double q3_;
    double high_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BoxPlotOutlier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.BoxPlotOutlier) */ {
 public:
  inline BoxPlotOutlier() : BoxPlotOutlier(nullptr) {}
  ~BoxPlotOutlier() override;
  explicit PROTOBUF_CONSTEXPR BoxPlotOutlier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxPlotOutlier(const BoxPlotOutlier& from);
  BoxPlotOutlier(BoxPlotOutlier&& from) noexcept
    : BoxPlotOutlier() {
    *this = ::std::move(from);
  }

  inline BoxPlotOutlier& operator=(const BoxPlotOutlier& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxPlotOutlier& operator=(BoxPlotOutlier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxPlotOutlier& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxPlotOutlier* internal_default_instance() {
    return reinterpret_cast<const BoxPlotOutlier*>(
               &_BoxPlotOutlier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BoxPlotOutlier& a, BoxPlotOutlier& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxPlotOutlier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxPlotOutlier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoxPlotOutlier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoxPlotOutlier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoxPlotOutlier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoxPlotOutlier& from) {
    BoxPlotOutlier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxPlotOutlier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.BoxPlotOutlier";
  }
  protected:
  explicit BoxPlotOutlier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoryIndexFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // uint64 category_index = 1;
  void clear_category_index();
  uint64_t category_index() const;
  void set_category_index(uint64_t value);
  private:
  uint64_t _internal_category_index() const;
  void _internal_set_category_index(uint64_t value);
  public:

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.BoxPlotOutlier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t category_index_;
    double value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BoxPlotDataPointDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.BoxPlotDataPointDef) */ {
 public:
  inline BoxPlotDataPointDef() : BoxPlotDataPointDef(nullptr) {}
  ~BoxPlotDataPointDef() override;
  explicit PROTOBUF_CONSTEXPR BoxPlotDataPointDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxPlotDataPointDef(const BoxPlotDataPointDef& from);
  BoxPlotDataPointDef(BoxPlotDataPointDef&& from) noexcept
    : BoxPlotDataPointDef() {
    *this = ::std::move(from);
  }

  inline BoxPlotDataPointDef& operator=(const BoxPlotDataPointDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxPlotDataPointDef& operator=(BoxPlotDataPointDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxPlotDataPointDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxPlotDataPointDef* internal_default_instance() {
    return reinterpret_cast<const BoxPlotDataPointDef*>(
               &_BoxPlotDataPointDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BoxPlotDataPointDef& a, BoxPlotDataPointDef& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxPlotDataPointDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxPlotDataPointDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoxPlotDataPointDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoxPlotDataPointDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoxPlotDataPointDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoxPlotDataPointDef& from) {
    BoxPlotDataPointDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxPlotDataPointDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.BoxPlotDataPointDef";
  }
  protected:
  explicit BoxPlotDataPointDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutliersFieldNumber = 1,
    kPointsFieldNumber = 2,
  };
  // repeated .epoch_proto.BoxPlotOutlier outliers = 1;
  int outliers_size() const;
  private:
  int _internal_outliers_size() const;
  public:
  void clear_outliers();
  ::epoch_proto::BoxPlotOutlier* mutable_outliers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotOutlier >*
      mutable_outliers();
  private:
  const ::epoch_proto::BoxPlotOutlier& _internal_outliers(int index) const;
  ::epoch_proto::BoxPlotOutlier* _internal_add_outliers();
  public:
  const ::epoch_proto::BoxPlotOutlier& outliers(int index) const;
  ::epoch_proto::BoxPlotOutlier* add_outliers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotOutlier >&
      outliers() const;

  // repeated .epoch_proto.BoxPlotDataPoint points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::epoch_proto::BoxPlotDataPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotDataPoint >*
      mutable_points();
  private:
  const ::epoch_proto::BoxPlotDataPoint& _internal_points(int index) const;
  ::epoch_proto::BoxPlotDataPoint* _internal_add_points();
  public:
  const ::epoch_proto::BoxPlotDataPoint& points(int index) const;
  ::epoch_proto::BoxPlotDataPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotDataPoint >&
      points() const;

  // @@protoc_insertion_point(class_scope:epoch_proto.BoxPlotDataPointDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotOutlier > outliers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotDataPoint > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BoxPlotDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.BoxPlotDef) */ {
 public:
  inline BoxPlotDef() : BoxPlotDef(nullptr) {}
  ~BoxPlotDef() override;
  explicit PROTOBUF_CONSTEXPR BoxPlotDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxPlotDef(const BoxPlotDef& from);
  BoxPlotDef(BoxPlotDef&& from) noexcept
    : BoxPlotDef() {
    *this = ::std::move(from);
  }

  inline BoxPlotDef& operator=(const BoxPlotDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxPlotDef& operator=(BoxPlotDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxPlotDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxPlotDef* internal_default_instance() {
    return reinterpret_cast<const BoxPlotDef*>(
               &_BoxPlotDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BoxPlotDef& a, BoxPlotDef& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxPlotDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxPlotDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoxPlotDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoxPlotDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoxPlotDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoxPlotDef& from) {
    BoxPlotDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxPlotDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.BoxPlotDef";
  }
  protected:
  explicit BoxPlotDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChartDefFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .epoch_proto.ChartDef chart_def = 1;
  bool has_chart_def() const;
  private:
  bool _internal_has_chart_def() const;
  public:
  void clear_chart_def();
  const ::epoch_proto::ChartDef& chart_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::ChartDef* release_chart_def();
  ::epoch_proto::ChartDef* mutable_chart_def();
  void set_allocated_chart_def(::epoch_proto::ChartDef* chart_def);
  private:
  const ::epoch_proto::ChartDef& _internal_chart_def() const;
  ::epoch_proto::ChartDef* _internal_mutable_chart_def();
  public:
  void unsafe_arena_set_allocated_chart_def(
      ::epoch_proto::ChartDef* chart_def);
  ::epoch_proto::ChartDef* unsafe_arena_release_chart_def();

  // .epoch_proto.BoxPlotDataPointDef data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::epoch_proto::BoxPlotDataPointDef& data() const;
  PROTOBUF_NODISCARD ::epoch_proto::BoxPlotDataPointDef* release_data();
  ::epoch_proto::BoxPlotDataPointDef* mutable_data();
  void set_allocated_data(::epoch_proto::BoxPlotDataPointDef* data);
  private:
  const ::epoch_proto::BoxPlotDataPointDef& _internal_data() const;
  ::epoch_proto::BoxPlotDataPointDef* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::epoch_proto::BoxPlotDataPointDef* data);
  ::epoch_proto::BoxPlotDataPointDef* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:epoch_proto.BoxPlotDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::epoch_proto::ChartDef* chart_def_;
    ::epoch_proto::BoxPlotDataPointDef* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class XRangePoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.XRangePoint) */ {
 public:
  inline XRangePoint() : XRangePoint(nullptr) {}
  ~XRangePoint() override;
  explicit PROTOBUF_CONSTEXPR XRangePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XRangePoint(const XRangePoint& from);
  XRangePoint(XRangePoint&& from) noexcept
    : XRangePoint() {
    *this = ::std::move(from);
  }

  inline XRangePoint& operator=(const XRangePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline XRangePoint& operator=(XRangePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XRangePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const XRangePoint* internal_default_instance() {
    return reinterpret_cast<const XRangePoint*>(
               &_XRangePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(XRangePoint& a, XRangePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(XRangePoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XRangePoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XRangePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XRangePoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XRangePoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const XRangePoint& from) {
    XRangePoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRangePoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.XRangePoint";
  }
  protected:
  explicit XRangePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kX2FieldNumber = 2,
    kYFieldNumber = 3,
    kIsLongFieldNumber = 4,
  };
  // int64 x = 1;
  void clear_x();
  int64_t x() const;
  void set_x(int64_t value);
  private:
  int64_t _internal_x() const;
  void _internal_set_x(int64_t value);
  public:

  // int64 x2 = 2;
  void clear_x2();
  int64_t x2() const;
  void set_x2(int64_t value);
  private:
  int64_t _internal_x2() const;
  void _internal_set_x2(int64_t value);
  public:

  // uint64 y = 3;
  void clear_y();
  uint64_t y() const;
  void set_y(uint64_t value);
  private:
  uint64_t _internal_y() const;
  void _internal_set_y(uint64_t value);
  public:

  // bool is_long = 4;
  void clear_is_long();
  bool is_long() const;
  void set_is_long(bool value);
  private:
  bool _internal_is_long() const;
  void _internal_set_is_long(bool value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.XRangePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t x_;
    int64_t x2_;
    uint64_t y_;
    bool is_long_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class XRangeDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.XRangeDef) */ {
 public:
  inline XRangeDef() : XRangeDef(nullptr) {}
  ~XRangeDef() override;
  explicit PROTOBUF_CONSTEXPR XRangeDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XRangeDef(const XRangeDef& from);
  XRangeDef(XRangeDef&& from) noexcept
    : XRangeDef() {
    *this = ::std::move(from);
  }

  inline XRangeDef& operator=(const XRangeDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline XRangeDef& operator=(XRangeDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XRangeDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const XRangeDef* internal_default_instance() {
    return reinterpret_cast<const XRangeDef*>(
               &_XRangeDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(XRangeDef& a, XRangeDef& b) {
    a.Swap(&b);
  }
  inline void Swap(XRangeDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XRangeDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XRangeDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XRangeDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XRangeDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const XRangeDef& from) {
    XRangeDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRangeDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.XRangeDef";
  }
  protected:
  explicit XRangeDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 2,
    kPointsFieldNumber = 3,
    kChartDefFieldNumber = 1,
  };
  // repeated string categories = 2;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, size_t size);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();
  private:
  const std::string& _internal_categories(int index) const;
  std::string* _internal_add_categories();
  public:

  // repeated .epoch_proto.XRangePoint points = 3;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::epoch_proto::XRangePoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::XRangePoint >*
      mutable_points();
  private:
  const ::epoch_proto::XRangePoint& _internal_points(int index) const;
  ::epoch_proto::XRangePoint* _internal_add_points();
  public:
  const ::epoch_proto::XRangePoint& points(int index) const;
  ::epoch_proto::XRangePoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::XRangePoint >&
      points() const;

  // .epoch_proto.ChartDef chart_def = 1;
  bool has_chart_def() const;
  private:
  bool _internal_has_chart_def() const;
  public:
  void clear_chart_def();
  const ::epoch_proto::ChartDef& chart_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::ChartDef* release_chart_def();
  ::epoch_proto::ChartDef* mutable_chart_def();
  void set_allocated_chart_def(::epoch_proto::ChartDef* chart_def);
  private:
  const ::epoch_proto::ChartDef& _internal_chart_def() const;
  ::epoch_proto::ChartDef* _internal_mutable_chart_def();
  public:
  void unsafe_arena_set_allocated_chart_def(
      ::epoch_proto::ChartDef* chart_def);
  ::epoch_proto::ChartDef* unsafe_arena_release_chart_def();

  // @@protoc_insertion_point(class_scope:epoch_proto.XRangeDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::XRangePoint > points_;
    ::epoch_proto::ChartDef* chart_def_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class PieData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.PieData) */ {
 public:
  inline PieData() : PieData(nullptr) {}
  ~PieData() override;
  explicit PROTOBUF_CONSTEXPR PieData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PieData(const PieData& from);
  PieData(PieData&& from) noexcept
    : PieData() {
    *this = ::std::move(from);
  }

  inline PieData& operator=(const PieData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PieData& operator=(PieData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PieData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PieData* internal_default_instance() {
    return reinterpret_cast<const PieData*>(
               &_PieData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PieData& a, PieData& b) {
    a.Swap(&b);
  }
  inline void Swap(PieData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PieData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PieData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PieData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PieData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PieData& from) {
    PieData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PieData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.PieData";
  }
  protected:
  explicit PieData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.PieData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    double y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class PieDataDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.PieDataDef) */ {
 public:
  inline PieDataDef() : PieDataDef(nullptr) {}
  ~PieDataDef() override;
  explicit PROTOBUF_CONSTEXPR PieDataDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PieDataDef(const PieDataDef& from);
  PieDataDef(PieDataDef&& from) noexcept
    : PieDataDef() {
    *this = ::std::move(from);
  }

  inline PieDataDef& operator=(const PieDataDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline PieDataDef& operator=(PieDataDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PieDataDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const PieDataDef* internal_default_instance() {
    return reinterpret_cast<const PieDataDef*>(
               &_PieDataDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PieDataDef& a, PieDataDef& b) {
    a.Swap(&b);
  }
  inline void Swap(PieDataDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PieDataDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PieDataDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PieDataDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PieDataDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PieDataDef& from) {
    PieDataDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PieDataDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.PieDataDef";
  }
  protected:
  explicit PieDataDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kNameFieldNumber = 1,
    kSizeFieldNumber = 3,
    kInnerSizeFieldNumber = 4,
  };
  // repeated .epoch_proto.PieData points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::epoch_proto::PieData* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieData >*
      mutable_points();
  private:
  const ::epoch_proto::PieData& _internal_points(int index) const;
  ::epoch_proto::PieData* _internal_add_points();
  public:
  const ::epoch_proto::PieData& points(int index) const;
  ::epoch_proto::PieData* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieData >&
      points() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string size = 3;
  void clear_size();
  const std::string& size() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_size(ArgT0&& arg0, ArgT... args);
  std::string* mutable_size();
  PROTOBUF_NODISCARD std::string* release_size();
  void set_allocated_size(std::string* size);
  private:
  const std::string& _internal_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_size(const std::string& value);
  std::string* _internal_mutable_size();
  public:

  // optional string inner_size = 4;
  bool has_inner_size() const;
  private:
  bool _internal_has_inner_size() const;
  public:
  void clear_inner_size();
  const std::string& inner_size() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inner_size(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inner_size();
  PROTOBUF_NODISCARD std::string* release_inner_size();
  void set_allocated_inner_size(std::string* inner_size);
  private:
  const std::string& _internal_inner_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inner_size(const std::string& value);
  std::string* _internal_mutable_inner_size();
  public:

  // @@protoc_insertion_point(class_scope:epoch_proto.PieDataDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieData > points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inner_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class PieDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.PieDef) */ {
 public:
  inline PieDef() : PieDef(nullptr) {}
  ~PieDef() override;
  explicit PROTOBUF_CONSTEXPR PieDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PieDef(const PieDef& from);
  PieDef(PieDef&& from) noexcept
    : PieDef() {
    *this = ::std::move(from);
  }

  inline PieDef& operator=(const PieDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline PieDef& operator=(PieDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PieDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const PieDef* internal_default_instance() {
    return reinterpret_cast<const PieDef*>(
               &_PieDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PieDef& a, PieDef& b) {
    a.Swap(&b);
  }
  inline void Swap(PieDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PieDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PieDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PieDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PieDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PieDef& from) {
    PieDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PieDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.PieDef";
  }
  protected:
  explicit PieDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kChartDefFieldNumber = 1,
  };
  // repeated .epoch_proto.PieDataDef data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::epoch_proto::PieDataDef* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieDataDef >*
      mutable_data();
  private:
  const ::epoch_proto::PieDataDef& _internal_data(int index) const;
  ::epoch_proto::PieDataDef* _internal_add_data();
  public:
  const ::epoch_proto::PieDataDef& data(int index) const;
  ::epoch_proto::PieDataDef* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieDataDef >&
      data() const;

  // .epoch_proto.ChartDef chart_def = 1;
  bool has_chart_def() const;
  private:
  bool _internal_has_chart_def() const;
  public:
  void clear_chart_def();
  const ::epoch_proto::ChartDef& chart_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::ChartDef* release_chart_def();
  ::epoch_proto::ChartDef* mutable_chart_def();
  void set_allocated_chart_def(::epoch_proto::ChartDef* chart_def);
  private:
  const ::epoch_proto::ChartDef& _internal_chart_def() const;
  ::epoch_proto::ChartDef* _internal_mutable_chart_def();
  public:
  void unsafe_arena_set_allocated_chart_def(
      ::epoch_proto::ChartDef* chart_def);
  ::epoch_proto::ChartDef* unsafe_arena_release_chart_def();

  // @@protoc_insertion_point(class_scope:epoch_proto.PieDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieDataDef > data_;
    ::epoch_proto::ChartDef* chart_def_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Chart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:epoch_proto.Chart) */ {
 public:
  inline Chart() : Chart(nullptr) {}
  ~Chart() override;
  explicit PROTOBUF_CONSTEXPR Chart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chart(const Chart& from);
  Chart(Chart&& from) noexcept
    : Chart() {
    *this = ::std::move(from);
  }

  inline Chart& operator=(const Chart& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chart& operator=(Chart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chart& default_instance() {
    return *internal_default_instance();
  }
  enum ChartTypeCase {
    kLinesDef = 1,
    kHeatMapDef = 2,
    kBarDef = 3,
    kHistogramDef = 4,
    kBoxPlotDef = 5,
    kXRangeDef = 6,
    kPieDef = 7,
    CHART_TYPE_NOT_SET = 0,
  };

  static inline const Chart* internal_default_instance() {
    return reinterpret_cast<const Chart*>(
               &_Chart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Chart& a, Chart& b) {
    a.Swap(&b);
  }
  inline void Swap(Chart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Chart& from) {
    Chart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "epoch_proto.Chart";
  }
  protected:
  explicit Chart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinesDefFieldNumber = 1,
    kHeatMapDefFieldNumber = 2,
    kBarDefFieldNumber = 3,
    kHistogramDefFieldNumber = 4,
    kBoxPlotDefFieldNumber = 5,
    kXRangeDefFieldNumber = 6,
    kPieDefFieldNumber = 7,
  };
  // .epoch_proto.LinesDef lines_def = 1;
  bool has_lines_def() const;
  private:
  bool _internal_has_lines_def() const;
  public:
  void clear_lines_def();
  const ::epoch_proto::LinesDef& lines_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::LinesDef* release_lines_def();
  ::epoch_proto::LinesDef* mutable_lines_def();
  void set_allocated_lines_def(::epoch_proto::LinesDef* lines_def);
  private:
  const ::epoch_proto::LinesDef& _internal_lines_def() const;
  ::epoch_proto::LinesDef* _internal_mutable_lines_def();
  public:
  void unsafe_arena_set_allocated_lines_def(
      ::epoch_proto::LinesDef* lines_def);
  ::epoch_proto::LinesDef* unsafe_arena_release_lines_def();

  // .epoch_proto.HeatMapDef heat_map_def = 2;
  bool has_heat_map_def() const;
  private:
  bool _internal_has_heat_map_def() const;
  public:
  void clear_heat_map_def();
  const ::epoch_proto::HeatMapDef& heat_map_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::HeatMapDef* release_heat_map_def();
  ::epoch_proto::HeatMapDef* mutable_heat_map_def();
  void set_allocated_heat_map_def(::epoch_proto::HeatMapDef* heat_map_def);
  private:
  const ::epoch_proto::HeatMapDef& _internal_heat_map_def() const;
  ::epoch_proto::HeatMapDef* _internal_mutable_heat_map_def();
  public:
  void unsafe_arena_set_allocated_heat_map_def(
      ::epoch_proto::HeatMapDef* heat_map_def);
  ::epoch_proto::HeatMapDef* unsafe_arena_release_heat_map_def();

  // .epoch_proto.BarDef bar_def = 3;
  bool has_bar_def() const;
  private:
  bool _internal_has_bar_def() const;
  public:
  void clear_bar_def();
  const ::epoch_proto::BarDef& bar_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::BarDef* release_bar_def();
  ::epoch_proto::BarDef* mutable_bar_def();
  void set_allocated_bar_def(::epoch_proto::BarDef* bar_def);
  private:
  const ::epoch_proto::BarDef& _internal_bar_def() const;
  ::epoch_proto::BarDef* _internal_mutable_bar_def();
  public:
  void unsafe_arena_set_allocated_bar_def(
      ::epoch_proto::BarDef* bar_def);
  ::epoch_proto::BarDef* unsafe_arena_release_bar_def();

  // .epoch_proto.HistogramDef histogram_def = 4;
  bool has_histogram_def() const;
  private:
  bool _internal_has_histogram_def() const;
  public:
  void clear_histogram_def();
  const ::epoch_proto::HistogramDef& histogram_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::HistogramDef* release_histogram_def();
  ::epoch_proto::HistogramDef* mutable_histogram_def();
  void set_allocated_histogram_def(::epoch_proto::HistogramDef* histogram_def);
  private:
  const ::epoch_proto::HistogramDef& _internal_histogram_def() const;
  ::epoch_proto::HistogramDef* _internal_mutable_histogram_def();
  public:
  void unsafe_arena_set_allocated_histogram_def(
      ::epoch_proto::HistogramDef* histogram_def);
  ::epoch_proto::HistogramDef* unsafe_arena_release_histogram_def();

  // .epoch_proto.BoxPlotDef box_plot_def = 5;
  bool has_box_plot_def() const;
  private:
  bool _internal_has_box_plot_def() const;
  public:
  void clear_box_plot_def();
  const ::epoch_proto::BoxPlotDef& box_plot_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::BoxPlotDef* release_box_plot_def();
  ::epoch_proto::BoxPlotDef* mutable_box_plot_def();
  void set_allocated_box_plot_def(::epoch_proto::BoxPlotDef* box_plot_def);
  private:
  const ::epoch_proto::BoxPlotDef& _internal_box_plot_def() const;
  ::epoch_proto::BoxPlotDef* _internal_mutable_box_plot_def();
  public:
  void unsafe_arena_set_allocated_box_plot_def(
      ::epoch_proto::BoxPlotDef* box_plot_def);
  ::epoch_proto::BoxPlotDef* unsafe_arena_release_box_plot_def();

  // .epoch_proto.XRangeDef x_range_def = 6;
  bool has_x_range_def() const;
  private:
  bool _internal_has_x_range_def() const;
  public:
  void clear_x_range_def();
  const ::epoch_proto::XRangeDef& x_range_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::XRangeDef* release_x_range_def();
  ::epoch_proto::XRangeDef* mutable_x_range_def();
  void set_allocated_x_range_def(::epoch_proto::XRangeDef* x_range_def);
  private:
  const ::epoch_proto::XRangeDef& _internal_x_range_def() const;
  ::epoch_proto::XRangeDef* _internal_mutable_x_range_def();
  public:
  void unsafe_arena_set_allocated_x_range_def(
      ::epoch_proto::XRangeDef* x_range_def);
  ::epoch_proto::XRangeDef* unsafe_arena_release_x_range_def();

  // .epoch_proto.PieDef pie_def = 7;
  bool has_pie_def() const;
  private:
  bool _internal_has_pie_def() const;
  public:
  void clear_pie_def();
  const ::epoch_proto::PieDef& pie_def() const;
  PROTOBUF_NODISCARD ::epoch_proto::PieDef* release_pie_def();
  ::epoch_proto::PieDef* mutable_pie_def();
  void set_allocated_pie_def(::epoch_proto::PieDef* pie_def);
  private:
  const ::epoch_proto::PieDef& _internal_pie_def() const;
  ::epoch_proto::PieDef* _internal_mutable_pie_def();
  public:
  void unsafe_arena_set_allocated_pie_def(
      ::epoch_proto::PieDef* pie_def);
  ::epoch_proto::PieDef* unsafe_arena_release_pie_def();

  void clear_chart_type();
  ChartTypeCase chart_type_case() const;
  // @@protoc_insertion_point(class_scope:epoch_proto.Chart)
 private:
  class _Internal;
  void set_has_lines_def();
  void set_has_heat_map_def();
  void set_has_bar_def();
  void set_has_histogram_def();
  void set_has_box_plot_def();
  void set_has_x_range_def();
  void set_has_pie_def();

  inline bool has_chart_type() const;
  inline void clear_has_chart_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ChartTypeUnion {
      constexpr ChartTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::epoch_proto::LinesDef* lines_def_;
      ::epoch_proto::HeatMapDef* heat_map_def_;
      ::epoch_proto::BarDef* bar_def_;
      ::epoch_proto::HistogramDef* histogram_def_;
      ::epoch_proto::BoxPlotDef* box_plot_def_;
      ::epoch_proto::XRangeDef* x_range_def_;
      ::epoch_proto::PieDef* pie_def_;
    } chart_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chart_5fdef_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AxisDef

// optional .epoch_proto.AxisType type = 1;
inline bool AxisDef::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AxisDef::has_type() const {
  return _internal_has_type();
}
inline void AxisDef::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::epoch_proto::AxisType AxisDef::_internal_type() const {
  return static_cast< ::epoch_proto::AxisType >(_impl_.type_);
}
inline ::epoch_proto::AxisType AxisDef::type() const {
  // @@protoc_insertion_point(field_get:epoch_proto.AxisDef.type)
  return _internal_type();
}
inline void AxisDef::_internal_set_type(::epoch_proto::AxisType value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void AxisDef::set_type(::epoch_proto::AxisType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:epoch_proto.AxisDef.type)
}

// optional string label = 2;
inline bool AxisDef::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AxisDef::has_label() const {
  return _internal_has_label();
}
inline void AxisDef::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AxisDef::label() const {
  // @@protoc_insertion_point(field_get:epoch_proto.AxisDef.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AxisDef::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.AxisDef.label)
}
inline std::string* AxisDef::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:epoch_proto.AxisDef.label)
  return _s;
}
inline const std::string& AxisDef::_internal_label() const {
  return _impl_.label_.Get();
}
inline void AxisDef::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* AxisDef::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* AxisDef::release_label() {
  // @@protoc_insertion_point(field_release:epoch_proto.AxisDef.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AxisDef::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.AxisDef.label)
}

// repeated string categories = 3;
inline int AxisDef::_internal_categories_size() const {
  return _impl_.categories_.size();
}
inline int AxisDef::categories_size() const {
  return _internal_categories_size();
}
inline void AxisDef::clear_categories() {
  _impl_.categories_.Clear();
}
inline std::string* AxisDef::add_categories() {
  std::string* _s = _internal_add_categories();
  // @@protoc_insertion_point(field_add_mutable:epoch_proto.AxisDef.categories)
  return _s;
}
inline const std::string& AxisDef::_internal_categories(int index) const {
  return _impl_.categories_.Get(index);
}
inline const std::string& AxisDef::categories(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.AxisDef.categories)
  return _internal_categories(index);
}
inline std::string* AxisDef::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.AxisDef.categories)
  return _impl_.categories_.Mutable(index);
}
inline void AxisDef::set_categories(int index, const std::string& value) {
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:epoch_proto.AxisDef.categories)
}
inline void AxisDef::set_categories(int index, std::string&& value) {
  _impl_.categories_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:epoch_proto.AxisDef.categories)
}
inline void AxisDef::set_categories(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:epoch_proto.AxisDef.categories)
}
inline void AxisDef::set_categories(int index, const char* value, size_t size) {
  _impl_.categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:epoch_proto.AxisDef.categories)
}
inline std::string* AxisDef::_internal_add_categories() {
  return _impl_.categories_.Add();
}
inline void AxisDef::add_categories(const std::string& value) {
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:epoch_proto.AxisDef.categories)
}
inline void AxisDef::add_categories(std::string&& value) {
  _impl_.categories_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:epoch_proto.AxisDef.categories)
}
inline void AxisDef::add_categories(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:epoch_proto.AxisDef.categories)
}
inline void AxisDef::add_categories(const char* value, size_t size) {
  _impl_.categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:epoch_proto.AxisDef.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AxisDef::categories() const {
  // @@protoc_insertion_point(field_list:epoch_proto.AxisDef.categories)
  return _impl_.categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AxisDef::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.AxisDef.categories)
  return &_impl_.categories_;
}

// -------------------------------------------------------------------

// ChartDef

// string id = 1;
inline void ChartDef::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ChartDef::id() const {
  // @@protoc_insertion_point(field_get:epoch_proto.ChartDef.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChartDef::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.ChartDef.id)
}
inline std::string* ChartDef::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:epoch_proto.ChartDef.id)
  return _s;
}
inline const std::string& ChartDef::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ChartDef::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChartDef::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChartDef::release_id() {
  // @@protoc_insertion_point(field_release:epoch_proto.ChartDef.id)
  return _impl_.id_.Release();
}
inline void ChartDef::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.ChartDef.id)
}

// string title = 2;
inline void ChartDef::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ChartDef::title() const {
  // @@protoc_insertion_point(field_get:epoch_proto.ChartDef.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChartDef::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.ChartDef.title)
}
inline std::string* ChartDef::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:epoch_proto.ChartDef.title)
  return _s;
}
inline const std::string& ChartDef::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ChartDef::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ChartDef::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ChartDef::release_title() {
  // @@protoc_insertion_point(field_release:epoch_proto.ChartDef.title)
  return _impl_.title_.Release();
}
inline void ChartDef::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.ChartDef.title)
}

// .epoch_proto.EpochFolioDashboardWidget type = 3;
inline void ChartDef::clear_type() {
  _impl_.type_ = 0;
}
inline ::epoch_proto::EpochFolioDashboardWidget ChartDef::_internal_type() const {
  return static_cast< ::epoch_proto::EpochFolioDashboardWidget >(_impl_.type_);
}
inline ::epoch_proto::EpochFolioDashboardWidget ChartDef::type() const {
  // @@protoc_insertion_point(field_get:epoch_proto.ChartDef.type)
  return _internal_type();
}
inline void ChartDef::_internal_set_type(::epoch_proto::EpochFolioDashboardWidget value) {
  
  _impl_.type_ = value;
}
inline void ChartDef::set_type(::epoch_proto::EpochFolioDashboardWidget value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:epoch_proto.ChartDef.type)
}

// string category = 4;
inline void ChartDef::clear_category() {
  _impl_.category_.ClearToEmpty();
}
inline const std::string& ChartDef::category() const {
  // @@protoc_insertion_point(field_get:epoch_proto.ChartDef.category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChartDef::set_category(ArgT0&& arg0, ArgT... args) {
 
 _impl_.category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.ChartDef.category)
}
inline std::string* ChartDef::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:epoch_proto.ChartDef.category)
  return _s;
}
inline const std::string& ChartDef::_internal_category() const {
  return _impl_.category_.Get();
}
inline void ChartDef::_internal_set_category(const std::string& value) {
  
  _impl_.category_.Set(value, GetArenaForAllocation());
}
inline std::string* ChartDef::_internal_mutable_category() {
  
  return _impl_.category_.Mutable(GetArenaForAllocation());
}
inline std::string* ChartDef::release_category() {
  // @@protoc_insertion_point(field_release:epoch_proto.ChartDef.category)
  return _impl_.category_.Release();
}
inline void ChartDef::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  _impl_.category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.category_.IsDefault()) {
    _impl_.category_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.ChartDef.category)
}

// optional .epoch_proto.AxisDef y_axis = 5;
inline bool ChartDef::_internal_has_y_axis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_axis_ != nullptr);
  return value;
}
inline bool ChartDef::has_y_axis() const {
  return _internal_has_y_axis();
}
inline void ChartDef::clear_y_axis() {
  if (_impl_.y_axis_ != nullptr) _impl_.y_axis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epoch_proto::AxisDef& ChartDef::_internal_y_axis() const {
  const ::epoch_proto::AxisDef* p = _impl_.y_axis_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::AxisDef&>(
      ::epoch_proto::_AxisDef_default_instance_);
}
inline const ::epoch_proto::AxisDef& ChartDef::y_axis() const {
  // @@protoc_insertion_point(field_get:epoch_proto.ChartDef.y_axis)
  return _internal_y_axis();
}
inline void ChartDef::unsafe_arena_set_allocated_y_axis(
    ::epoch_proto::AxisDef* y_axis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.y_axis_);
  }
  _impl_.y_axis_ = y_axis;
  if (y_axis) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.ChartDef.y_axis)
}
inline ::epoch_proto::AxisDef* ChartDef::release_y_axis() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epoch_proto::AxisDef* temp = _impl_.y_axis_;
  _impl_.y_axis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::AxisDef* ChartDef::unsafe_arena_release_y_axis() {
  // @@protoc_insertion_point(field_release:epoch_proto.ChartDef.y_axis)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epoch_proto::AxisDef* temp = _impl_.y_axis_;
  _impl_.y_axis_ = nullptr;
  return temp;
}
inline ::epoch_proto::AxisDef* ChartDef::_internal_mutable_y_axis() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.y_axis_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::AxisDef>(GetArenaForAllocation());
    _impl_.y_axis_ = p;
  }
  return _impl_.y_axis_;
}
inline ::epoch_proto::AxisDef* ChartDef::mutable_y_axis() {
  ::epoch_proto::AxisDef* _msg = _internal_mutable_y_axis();
  // @@protoc_insertion_point(field_mutable:epoch_proto.ChartDef.y_axis)
  return _msg;
}
inline void ChartDef::set_allocated_y_axis(::epoch_proto::AxisDef* y_axis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.y_axis_;
  }
  if (y_axis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(y_axis);
    if (message_arena != submessage_arena) {
      y_axis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y_axis, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.y_axis_ = y_axis;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.ChartDef.y_axis)
}

// optional .epoch_proto.AxisDef x_axis = 6;
inline bool ChartDef::_internal_has_x_axis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_axis_ != nullptr);
  return value;
}
inline bool ChartDef::has_x_axis() const {
  return _internal_has_x_axis();
}
inline void ChartDef::clear_x_axis() {
  if (_impl_.x_axis_ != nullptr) _impl_.x_axis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::epoch_proto::AxisDef& ChartDef::_internal_x_axis() const {
  const ::epoch_proto::AxisDef* p = _impl_.x_axis_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::AxisDef&>(
      ::epoch_proto::_AxisDef_default_instance_);
}
inline const ::epoch_proto::AxisDef& ChartDef::x_axis() const {
  // @@protoc_insertion_point(field_get:epoch_proto.ChartDef.x_axis)
  return _internal_x_axis();
}
inline void ChartDef::unsafe_arena_set_allocated_x_axis(
    ::epoch_proto::AxisDef* x_axis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.x_axis_);
  }
  _impl_.x_axis_ = x_axis;
  if (x_axis) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.ChartDef.x_axis)
}
inline ::epoch_proto::AxisDef* ChartDef::release_x_axis() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epoch_proto::AxisDef* temp = _impl_.x_axis_;
  _impl_.x_axis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::AxisDef* ChartDef::unsafe_arena_release_x_axis() {
  // @@protoc_insertion_point(field_release:epoch_proto.ChartDef.x_axis)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::epoch_proto::AxisDef* temp = _impl_.x_axis_;
  _impl_.x_axis_ = nullptr;
  return temp;
}
inline ::epoch_proto::AxisDef* ChartDef::_internal_mutable_x_axis() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.x_axis_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::AxisDef>(GetArenaForAllocation());
    _impl_.x_axis_ = p;
  }
  return _impl_.x_axis_;
}
inline ::epoch_proto::AxisDef* ChartDef::mutable_x_axis() {
  ::epoch_proto::AxisDef* _msg = _internal_mutable_x_axis();
  // @@protoc_insertion_point(field_mutable:epoch_proto.ChartDef.x_axis)
  return _msg;
}
inline void ChartDef::set_allocated_x_axis(::epoch_proto::AxisDef* x_axis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.x_axis_;
  }
  if (x_axis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(x_axis);
    if (message_arena != submessage_arena) {
      x_axis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x_axis, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.x_axis_ = x_axis;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.ChartDef.x_axis)
}

// -------------------------------------------------------------------

// StraightLineDef

// string title = 1;
inline void StraightLineDef::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& StraightLineDef::title() const {
  // @@protoc_insertion_point(field_get:epoch_proto.StraightLineDef.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StraightLineDef::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.StraightLineDef.title)
}
inline std::string* StraightLineDef::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:epoch_proto.StraightLineDef.title)
  return _s;
}
inline const std::string& StraightLineDef::_internal_title() const {
  return _impl_.title_.Get();
}
inline void StraightLineDef::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* StraightLineDef::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* StraightLineDef::release_title() {
  // @@protoc_insertion_point(field_release:epoch_proto.StraightLineDef.title)
  return _impl_.title_.Release();
}
inline void StraightLineDef::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.StraightLineDef.title)
}

// double value = 2;
inline void StraightLineDef::clear_value() {
  _impl_.value_ = 0;
}
inline double StraightLineDef::_internal_value() const {
  return _impl_.value_;
}
inline double StraightLineDef::value() const {
  // @@protoc_insertion_point(field_get:epoch_proto.StraightLineDef.value)
  return _internal_value();
}
inline void StraightLineDef::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void StraightLineDef::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:epoch_proto.StraightLineDef.value)
}

// bool vertical = 3;
inline void StraightLineDef::clear_vertical() {
  _impl_.vertical_ = false;
}
inline bool StraightLineDef::_internal_vertical() const {
  return _impl_.vertical_;
}
inline bool StraightLineDef::vertical() const {
  // @@protoc_insertion_point(field_get:epoch_proto.StraightLineDef.vertical)
  return _internal_vertical();
}
inline void StraightLineDef::_internal_set_vertical(bool value) {
  
  _impl_.vertical_ = value;
}
inline void StraightLineDef::set_vertical(bool value) {
  _internal_set_vertical(value);
  // @@protoc_insertion_point(field_set:epoch_proto.StraightLineDef.vertical)
}

// -------------------------------------------------------------------

// Band

// .epoch_proto.Scalar from = 1;
inline bool Band::_internal_has_from() const {
  return this != internal_default_instance() && _impl_.from_ != nullptr;
}
inline bool Band::has_from() const {
  return _internal_has_from();
}
inline const ::epoch_proto::Scalar& Band::_internal_from() const {
  const ::epoch_proto::Scalar* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::Scalar&>(
      ::epoch_proto::_Scalar_default_instance_);
}
inline const ::epoch_proto::Scalar& Band::from() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Band.from)
  return _internal_from();
}
inline void Band::unsafe_arena_set_allocated_from(
    ::epoch_proto::Scalar* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Band.from)
}
inline ::epoch_proto::Scalar* Band::release_from() {
  
  ::epoch_proto::Scalar* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::Scalar* Band::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:epoch_proto.Band.from)
  
  ::epoch_proto::Scalar* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::epoch_proto::Scalar* Band::_internal_mutable_from() {
  
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::Scalar>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::epoch_proto::Scalar* Band::mutable_from() {
  ::epoch_proto::Scalar* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Band.from)
  return _msg;
}
inline void Band::set_allocated_from(::epoch_proto::Scalar* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from));
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Band.from)
}

// .epoch_proto.Scalar to = 2;
inline bool Band::_internal_has_to() const {
  return this != internal_default_instance() && _impl_.to_ != nullptr;
}
inline bool Band::has_to() const {
  return _internal_has_to();
}
inline const ::epoch_proto::Scalar& Band::_internal_to() const {
  const ::epoch_proto::Scalar* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::Scalar&>(
      ::epoch_proto::_Scalar_default_instance_);
}
inline const ::epoch_proto::Scalar& Band::to() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Band.to)
  return _internal_to();
}
inline void Band::unsafe_arena_set_allocated_to(
    ::epoch_proto::Scalar* to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = to;
  if (to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Band.to)
}
inline ::epoch_proto::Scalar* Band::release_to() {
  
  ::epoch_proto::Scalar* temp = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::Scalar* Band::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:epoch_proto.Band.to)
  
  ::epoch_proto::Scalar* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::epoch_proto::Scalar* Band::_internal_mutable_to() {
  
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::Scalar>(GetArenaForAllocation());
    _impl_.to_ = p;
  }
  return _impl_.to_;
}
inline ::epoch_proto::Scalar* Band::mutable_to() {
  ::epoch_proto::Scalar* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Band.to)
  return _msg;
}
inline void Band::set_allocated_to(::epoch_proto::Scalar* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_);
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(to));
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_ = to;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Band.to)
}

// -------------------------------------------------------------------

// Point

// int64 x = 1;
inline void Point::clear_x() {
  _impl_.x_ = int64_t{0};
}
inline int64_t Point::_internal_x() const {
  return _impl_.x_;
}
inline int64_t Point::x() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(int64_t value) {
  
  _impl_.x_ = value;
}
inline void Point::set_x(int64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:epoch_proto.Point.x)
}

// double y = 2;
inline void Point::clear_y() {
  _impl_.y_ = 0;
}
inline double Point::_internal_y() const {
  return _impl_.y_;
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Point::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:epoch_proto.Point.y)
}

// -------------------------------------------------------------------

// Line

// repeated .epoch_proto.Point data = 1;
inline int Line::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Line::data_size() const {
  return _internal_data_size();
}
inline void Line::clear_data() {
  _impl_.data_.Clear();
}
inline ::epoch_proto::Point* Line::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.Line.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Point >*
Line::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.Line.data)
  return &_impl_.data_;
}
inline const ::epoch_proto::Point& Line::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::epoch_proto::Point& Line::data(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.Line.data)
  return _internal_data(index);
}
inline ::epoch_proto::Point* Line::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::epoch_proto::Point* Line::add_data() {
  ::epoch_proto::Point* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:epoch_proto.Line.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Point >&
Line::data() const {
  // @@protoc_insertion_point(field_list:epoch_proto.Line.data)
  return _impl_.data_;
}

// string name = 2;
inline void Line::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Line::name() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Line.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Line::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.Line.name)
}
inline std::string* Line::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Line.name)
  return _s;
}
inline const std::string& Line::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Line::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Line::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Line::release_name() {
  // @@protoc_insertion_point(field_release:epoch_proto.Line.name)
  return _impl_.name_.Release();
}
inline void Line::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Line.name)
}

// optional string dash_style = 3;
inline bool Line::_internal_has_dash_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Line::has_dash_style() const {
  return _internal_has_dash_style();
}
inline void Line::clear_dash_style() {
  _impl_.dash_style_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Line::dash_style() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Line.dash_style)
  return _internal_dash_style();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Line::set_dash_style(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.dash_style_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.Line.dash_style)
}
inline std::string* Line::mutable_dash_style() {
  std::string* _s = _internal_mutable_dash_style();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Line.dash_style)
  return _s;
}
inline const std::string& Line::_internal_dash_style() const {
  return _impl_.dash_style_.Get();
}
inline void Line::_internal_set_dash_style(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dash_style_.Set(value, GetArenaForAllocation());
}
inline std::string* Line::_internal_mutable_dash_style() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dash_style_.Mutable(GetArenaForAllocation());
}
inline std::string* Line::release_dash_style() {
  // @@protoc_insertion_point(field_release:epoch_proto.Line.dash_style)
  if (!_internal_has_dash_style()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.dash_style_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dash_style_.IsDefault()) {
    _impl_.dash_style_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Line::set_allocated_dash_style(std::string* dash_style) {
  if (dash_style != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dash_style_.SetAllocated(dash_style, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dash_style_.IsDefault()) {
    _impl_.dash_style_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Line.dash_style)
}

// optional uint32 line_width = 4;
inline bool Line::_internal_has_line_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Line::has_line_width() const {
  return _internal_has_line_width();
}
inline void Line::clear_line_width() {
  _impl_.line_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Line::_internal_line_width() const {
  return _impl_.line_width_;
}
inline uint32_t Line::line_width() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Line.line_width)
  return _internal_line_width();
}
inline void Line::_internal_set_line_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.line_width_ = value;
}
inline void Line::set_line_width(uint32_t value) {
  _internal_set_line_width(value);
  // @@protoc_insertion_point(field_set:epoch_proto.Line.line_width)
}

// -------------------------------------------------------------------

// LinesDef

// .epoch_proto.ChartDef chart_def = 1;
inline bool LinesDef::_internal_has_chart_def() const {
  return this != internal_default_instance() && _impl_.chart_def_ != nullptr;
}
inline bool LinesDef::has_chart_def() const {
  return _internal_has_chart_def();
}
inline void LinesDef::clear_chart_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
}
inline const ::epoch_proto::ChartDef& LinesDef::_internal_chart_def() const {
  const ::epoch_proto::ChartDef* p = _impl_.chart_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::ChartDef&>(
      ::epoch_proto::_ChartDef_default_instance_);
}
inline const ::epoch_proto::ChartDef& LinesDef::chart_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.LinesDef.chart_def)
  return _internal_chart_def();
}
inline void LinesDef::unsafe_arena_set_allocated_chart_def(
    ::epoch_proto::ChartDef* chart_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chart_def_);
  }
  _impl_.chart_def_ = chart_def;
  if (chart_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.LinesDef.chart_def)
}
inline ::epoch_proto::ChartDef* LinesDef::release_chart_def() {
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::ChartDef* LinesDef::unsafe_arena_release_chart_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.LinesDef.chart_def)
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
  return temp;
}
inline ::epoch_proto::ChartDef* LinesDef::_internal_mutable_chart_def() {
  
  if (_impl_.chart_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::ChartDef>(GetArenaForAllocation());
    _impl_.chart_def_ = p;
  }
  return _impl_.chart_def_;
}
inline ::epoch_proto::ChartDef* LinesDef::mutable_chart_def() {
  ::epoch_proto::ChartDef* _msg = _internal_mutable_chart_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.LinesDef.chart_def)
  return _msg;
}
inline void LinesDef::set_allocated_chart_def(::epoch_proto::ChartDef* chart_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chart_def_;
  }
  if (chart_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chart_def);
    if (message_arena != submessage_arena) {
      chart_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chart_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chart_def_ = chart_def;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.LinesDef.chart_def)
}

// repeated .epoch_proto.Line lines = 2;
inline int LinesDef::_internal_lines_size() const {
  return _impl_.lines_.size();
}
inline int LinesDef::lines_size() const {
  return _internal_lines_size();
}
inline void LinesDef::clear_lines() {
  _impl_.lines_.Clear();
}
inline ::epoch_proto::Line* LinesDef::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.LinesDef.lines)
  return _impl_.lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Line >*
LinesDef::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.LinesDef.lines)
  return &_impl_.lines_;
}
inline const ::epoch_proto::Line& LinesDef::_internal_lines(int index) const {
  return _impl_.lines_.Get(index);
}
inline const ::epoch_proto::Line& LinesDef::lines(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.LinesDef.lines)
  return _internal_lines(index);
}
inline ::epoch_proto::Line* LinesDef::_internal_add_lines() {
  return _impl_.lines_.Add();
}
inline ::epoch_proto::Line* LinesDef::add_lines() {
  ::epoch_proto::Line* _add = _internal_add_lines();
  // @@protoc_insertion_point(field_add:epoch_proto.LinesDef.lines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Line >&
LinesDef::lines() const {
  // @@protoc_insertion_point(field_list:epoch_proto.LinesDef.lines)
  return _impl_.lines_;
}

// repeated .epoch_proto.StraightLineDef straight_lines = 3;
inline int LinesDef::_internal_straight_lines_size() const {
  return _impl_.straight_lines_.size();
}
inline int LinesDef::straight_lines_size() const {
  return _internal_straight_lines_size();
}
inline void LinesDef::clear_straight_lines() {
  _impl_.straight_lines_.Clear();
}
inline ::epoch_proto::StraightLineDef* LinesDef::mutable_straight_lines(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.LinesDef.straight_lines)
  return _impl_.straight_lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >*
LinesDef::mutable_straight_lines() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.LinesDef.straight_lines)
  return &_impl_.straight_lines_;
}
inline const ::epoch_proto::StraightLineDef& LinesDef::_internal_straight_lines(int index) const {
  return _impl_.straight_lines_.Get(index);
}
inline const ::epoch_proto::StraightLineDef& LinesDef::straight_lines(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.LinesDef.straight_lines)
  return _internal_straight_lines(index);
}
inline ::epoch_proto::StraightLineDef* LinesDef::_internal_add_straight_lines() {
  return _impl_.straight_lines_.Add();
}
inline ::epoch_proto::StraightLineDef* LinesDef::add_straight_lines() {
  ::epoch_proto::StraightLineDef* _add = _internal_add_straight_lines();
  // @@protoc_insertion_point(field_add:epoch_proto.LinesDef.straight_lines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >&
LinesDef::straight_lines() const {
  // @@protoc_insertion_point(field_list:epoch_proto.LinesDef.straight_lines)
  return _impl_.straight_lines_;
}

// repeated .epoch_proto.Band y_plot_bands = 4;
inline int LinesDef::_internal_y_plot_bands_size() const {
  return _impl_.y_plot_bands_.size();
}
inline int LinesDef::y_plot_bands_size() const {
  return _internal_y_plot_bands_size();
}
inline void LinesDef::clear_y_plot_bands() {
  _impl_.y_plot_bands_.Clear();
}
inline ::epoch_proto::Band* LinesDef::mutable_y_plot_bands(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.LinesDef.y_plot_bands)
  return _impl_.y_plot_bands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >*
LinesDef::mutable_y_plot_bands() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.LinesDef.y_plot_bands)
  return &_impl_.y_plot_bands_;
}
inline const ::epoch_proto::Band& LinesDef::_internal_y_plot_bands(int index) const {
  return _impl_.y_plot_bands_.Get(index);
}
inline const ::epoch_proto::Band& LinesDef::y_plot_bands(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.LinesDef.y_plot_bands)
  return _internal_y_plot_bands(index);
}
inline ::epoch_proto::Band* LinesDef::_internal_add_y_plot_bands() {
  return _impl_.y_plot_bands_.Add();
}
inline ::epoch_proto::Band* LinesDef::add_y_plot_bands() {
  ::epoch_proto::Band* _add = _internal_add_y_plot_bands();
  // @@protoc_insertion_point(field_add:epoch_proto.LinesDef.y_plot_bands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >&
LinesDef::y_plot_bands() const {
  // @@protoc_insertion_point(field_list:epoch_proto.LinesDef.y_plot_bands)
  return _impl_.y_plot_bands_;
}

// repeated .epoch_proto.Band x_plot_bands = 5;
inline int LinesDef::_internal_x_plot_bands_size() const {
  return _impl_.x_plot_bands_.size();
}
inline int LinesDef::x_plot_bands_size() const {
  return _internal_x_plot_bands_size();
}
inline void LinesDef::clear_x_plot_bands() {
  _impl_.x_plot_bands_.Clear();
}
inline ::epoch_proto::Band* LinesDef::mutable_x_plot_bands(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.LinesDef.x_plot_bands)
  return _impl_.x_plot_bands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >*
LinesDef::mutable_x_plot_bands() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.LinesDef.x_plot_bands)
  return &_impl_.x_plot_bands_;
}
inline const ::epoch_proto::Band& LinesDef::_internal_x_plot_bands(int index) const {
  return _impl_.x_plot_bands_.Get(index);
}
inline const ::epoch_proto::Band& LinesDef::x_plot_bands(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.LinesDef.x_plot_bands)
  return _internal_x_plot_bands(index);
}
inline ::epoch_proto::Band* LinesDef::_internal_add_x_plot_bands() {
  return _impl_.x_plot_bands_.Add();
}
inline ::epoch_proto::Band* LinesDef::add_x_plot_bands() {
  ::epoch_proto::Band* _add = _internal_add_x_plot_bands();
  // @@protoc_insertion_point(field_add:epoch_proto.LinesDef.x_plot_bands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::Band >&
LinesDef::x_plot_bands() const {
  // @@protoc_insertion_point(field_list:epoch_proto.LinesDef.x_plot_bands)
  return _impl_.x_plot_bands_;
}

// optional .epoch_proto.Line overlay = 6;
inline bool LinesDef::_internal_has_overlay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.overlay_ != nullptr);
  return value;
}
inline bool LinesDef::has_overlay() const {
  return _internal_has_overlay();
}
inline void LinesDef::clear_overlay() {
  if (_impl_.overlay_ != nullptr) _impl_.overlay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::epoch_proto::Line& LinesDef::_internal_overlay() const {
  const ::epoch_proto::Line* p = _impl_.overlay_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::Line&>(
      ::epoch_proto::_Line_default_instance_);
}
inline const ::epoch_proto::Line& LinesDef::overlay() const {
  // @@protoc_insertion_point(field_get:epoch_proto.LinesDef.overlay)
  return _internal_overlay();
}
inline void LinesDef::unsafe_arena_set_allocated_overlay(
    ::epoch_proto::Line* overlay) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overlay_);
  }
  _impl_.overlay_ = overlay;
  if (overlay) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.LinesDef.overlay)
}
inline ::epoch_proto::Line* LinesDef::release_overlay() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epoch_proto::Line* temp = _impl_.overlay_;
  _impl_.overlay_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::Line* LinesDef::unsafe_arena_release_overlay() {
  // @@protoc_insertion_point(field_release:epoch_proto.LinesDef.overlay)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::epoch_proto::Line* temp = _impl_.overlay_;
  _impl_.overlay_ = nullptr;
  return temp;
}
inline ::epoch_proto::Line* LinesDef::_internal_mutable_overlay() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.overlay_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::Line>(GetArenaForAllocation());
    _impl_.overlay_ = p;
  }
  return _impl_.overlay_;
}
inline ::epoch_proto::Line* LinesDef::mutable_overlay() {
  ::epoch_proto::Line* _msg = _internal_mutable_overlay();
  // @@protoc_insertion_point(field_mutable:epoch_proto.LinesDef.overlay)
  return _msg;
}
inline void LinesDef::set_allocated_overlay(::epoch_proto::Line* overlay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.overlay_;
  }
  if (overlay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(overlay);
    if (message_arena != submessage_arena) {
      overlay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overlay, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.overlay_ = overlay;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.LinesDef.overlay)
}

// bool stacked = 7;
inline void LinesDef::clear_stacked() {
  _impl_.stacked_ = false;
}
inline bool LinesDef::_internal_stacked() const {
  return _impl_.stacked_;
}
inline bool LinesDef::stacked() const {
  // @@protoc_insertion_point(field_get:epoch_proto.LinesDef.stacked)
  return _internal_stacked();
}
inline void LinesDef::_internal_set_stacked(bool value) {
  
  _impl_.stacked_ = value;
}
inline void LinesDef::set_stacked(bool value) {
  _internal_set_stacked(value);
  // @@protoc_insertion_point(field_set:epoch_proto.LinesDef.stacked)
}

// -------------------------------------------------------------------

// HeatMapPoint

// uint64 x = 1;
inline void HeatMapPoint::clear_x() {
  _impl_.x_ = uint64_t{0u};
}
inline uint64_t HeatMapPoint::_internal_x() const {
  return _impl_.x_;
}
inline uint64_t HeatMapPoint::x() const {
  // @@protoc_insertion_point(field_get:epoch_proto.HeatMapPoint.x)
  return _internal_x();
}
inline void HeatMapPoint::_internal_set_x(uint64_t value) {
  
  _impl_.x_ = value;
}
inline void HeatMapPoint::set_x(uint64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:epoch_proto.HeatMapPoint.x)
}

// uint64 y = 2;
inline void HeatMapPoint::clear_y() {
  _impl_.y_ = uint64_t{0u};
}
inline uint64_t HeatMapPoint::_internal_y() const {
  return _impl_.y_;
}
inline uint64_t HeatMapPoint::y() const {
  // @@protoc_insertion_point(field_get:epoch_proto.HeatMapPoint.y)
  return _internal_y();
}
inline void HeatMapPoint::_internal_set_y(uint64_t value) {
  
  _impl_.y_ = value;
}
inline void HeatMapPoint::set_y(uint64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:epoch_proto.HeatMapPoint.y)
}

// double value = 3;
inline void HeatMapPoint::clear_value() {
  _impl_.value_ = 0;
}
inline double HeatMapPoint::_internal_value() const {
  return _impl_.value_;
}
inline double HeatMapPoint::value() const {
  // @@protoc_insertion_point(field_get:epoch_proto.HeatMapPoint.value)
  return _internal_value();
}
inline void HeatMapPoint::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void HeatMapPoint::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:epoch_proto.HeatMapPoint.value)
}

// -------------------------------------------------------------------

// HeatMapDef

// .epoch_proto.ChartDef chart_def = 1;
inline bool HeatMapDef::_internal_has_chart_def() const {
  return this != internal_default_instance() && _impl_.chart_def_ != nullptr;
}
inline bool HeatMapDef::has_chart_def() const {
  return _internal_has_chart_def();
}
inline void HeatMapDef::clear_chart_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
}
inline const ::epoch_proto::ChartDef& HeatMapDef::_internal_chart_def() const {
  const ::epoch_proto::ChartDef* p = _impl_.chart_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::ChartDef&>(
      ::epoch_proto::_ChartDef_default_instance_);
}
inline const ::epoch_proto::ChartDef& HeatMapDef::chart_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.HeatMapDef.chart_def)
  return _internal_chart_def();
}
inline void HeatMapDef::unsafe_arena_set_allocated_chart_def(
    ::epoch_proto::ChartDef* chart_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chart_def_);
  }
  _impl_.chart_def_ = chart_def;
  if (chart_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.HeatMapDef.chart_def)
}
inline ::epoch_proto::ChartDef* HeatMapDef::release_chart_def() {
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::ChartDef* HeatMapDef::unsafe_arena_release_chart_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.HeatMapDef.chart_def)
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
  return temp;
}
inline ::epoch_proto::ChartDef* HeatMapDef::_internal_mutable_chart_def() {
  
  if (_impl_.chart_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::ChartDef>(GetArenaForAllocation());
    _impl_.chart_def_ = p;
  }
  return _impl_.chart_def_;
}
inline ::epoch_proto::ChartDef* HeatMapDef::mutable_chart_def() {
  ::epoch_proto::ChartDef* _msg = _internal_mutable_chart_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.HeatMapDef.chart_def)
  return _msg;
}
inline void HeatMapDef::set_allocated_chart_def(::epoch_proto::ChartDef* chart_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chart_def_;
  }
  if (chart_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chart_def);
    if (message_arena != submessage_arena) {
      chart_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chart_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chart_def_ = chart_def;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.HeatMapDef.chart_def)
}

// repeated .epoch_proto.HeatMapPoint points = 2;
inline int HeatMapDef::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int HeatMapDef::points_size() const {
  return _internal_points_size();
}
inline void HeatMapDef::clear_points() {
  _impl_.points_.Clear();
}
inline ::epoch_proto::HeatMapPoint* HeatMapDef::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.HeatMapDef.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::HeatMapPoint >*
HeatMapDef::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.HeatMapDef.points)
  return &_impl_.points_;
}
inline const ::epoch_proto::HeatMapPoint& HeatMapDef::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::epoch_proto::HeatMapPoint& HeatMapDef::points(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.HeatMapDef.points)
  return _internal_points(index);
}
inline ::epoch_proto::HeatMapPoint* HeatMapDef::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::epoch_proto::HeatMapPoint* HeatMapDef::add_points() {
  ::epoch_proto::HeatMapPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:epoch_proto.HeatMapDef.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::HeatMapPoint >&
HeatMapDef::points() const {
  // @@protoc_insertion_point(field_list:epoch_proto.HeatMapDef.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// BarDef

// .epoch_proto.ChartDef chart_def = 1;
inline bool BarDef::_internal_has_chart_def() const {
  return this != internal_default_instance() && _impl_.chart_def_ != nullptr;
}
inline bool BarDef::has_chart_def() const {
  return _internal_has_chart_def();
}
inline void BarDef::clear_chart_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
}
inline const ::epoch_proto::ChartDef& BarDef::_internal_chart_def() const {
  const ::epoch_proto::ChartDef* p = _impl_.chart_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::ChartDef&>(
      ::epoch_proto::_ChartDef_default_instance_);
}
inline const ::epoch_proto::ChartDef& BarDef::chart_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BarDef.chart_def)
  return _internal_chart_def();
}
inline void BarDef::unsafe_arena_set_allocated_chart_def(
    ::epoch_proto::ChartDef* chart_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chart_def_);
  }
  _impl_.chart_def_ = chart_def;
  if (chart_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.BarDef.chart_def)
}
inline ::epoch_proto::ChartDef* BarDef::release_chart_def() {
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::ChartDef* BarDef::unsafe_arena_release_chart_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.BarDef.chart_def)
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
  return temp;
}
inline ::epoch_proto::ChartDef* BarDef::_internal_mutable_chart_def() {
  
  if (_impl_.chart_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::ChartDef>(GetArenaForAllocation());
    _impl_.chart_def_ = p;
  }
  return _impl_.chart_def_;
}
inline ::epoch_proto::ChartDef* BarDef::mutable_chart_def() {
  ::epoch_proto::ChartDef* _msg = _internal_mutable_chart_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.BarDef.chart_def)
  return _msg;
}
inline void BarDef::set_allocated_chart_def(::epoch_proto::ChartDef* chart_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chart_def_;
  }
  if (chart_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chart_def);
    if (message_arena != submessage_arena) {
      chart_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chart_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chart_def_ = chart_def;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.BarDef.chart_def)
}

// .epoch_proto.Array data = 2;
inline bool BarDef::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool BarDef::has_data() const {
  return _internal_has_data();
}
inline const ::epoch_proto::Array& BarDef::_internal_data() const {
  const ::epoch_proto::Array* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::Array&>(
      ::epoch_proto::_Array_default_instance_);
}
inline const ::epoch_proto::Array& BarDef::data() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BarDef.data)
  return _internal_data();
}
inline void BarDef::unsafe_arena_set_allocated_data(
    ::epoch_proto::Array* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.BarDef.data)
}
inline ::epoch_proto::Array* BarDef::release_data() {
  
  ::epoch_proto::Array* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::Array* BarDef::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:epoch_proto.BarDef.data)
  
  ::epoch_proto::Array* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::epoch_proto::Array* BarDef::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::Array>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::epoch_proto::Array* BarDef::mutable_data() {
  ::epoch_proto::Array* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:epoch_proto.BarDef.data)
  return _msg;
}
inline void BarDef::set_allocated_data(::epoch_proto::Array* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.BarDef.data)
}

// repeated .epoch_proto.StraightLineDef straight_lines = 3;
inline int BarDef::_internal_straight_lines_size() const {
  return _impl_.straight_lines_.size();
}
inline int BarDef::straight_lines_size() const {
  return _internal_straight_lines_size();
}
inline void BarDef::clear_straight_lines() {
  _impl_.straight_lines_.Clear();
}
inline ::epoch_proto::StraightLineDef* BarDef::mutable_straight_lines(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.BarDef.straight_lines)
  return _impl_.straight_lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >*
BarDef::mutable_straight_lines() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.BarDef.straight_lines)
  return &_impl_.straight_lines_;
}
inline const ::epoch_proto::StraightLineDef& BarDef::_internal_straight_lines(int index) const {
  return _impl_.straight_lines_.Get(index);
}
inline const ::epoch_proto::StraightLineDef& BarDef::straight_lines(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.BarDef.straight_lines)
  return _internal_straight_lines(index);
}
inline ::epoch_proto::StraightLineDef* BarDef::_internal_add_straight_lines() {
  return _impl_.straight_lines_.Add();
}
inline ::epoch_proto::StraightLineDef* BarDef::add_straight_lines() {
  ::epoch_proto::StraightLineDef* _add = _internal_add_straight_lines();
  // @@protoc_insertion_point(field_add:epoch_proto.BarDef.straight_lines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >&
BarDef::straight_lines() const {
  // @@protoc_insertion_point(field_list:epoch_proto.BarDef.straight_lines)
  return _impl_.straight_lines_;
}

// optional uint32 bar_width = 4;
inline bool BarDef::_internal_has_bar_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BarDef::has_bar_width() const {
  return _internal_has_bar_width();
}
inline void BarDef::clear_bar_width() {
  _impl_.bar_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t BarDef::_internal_bar_width() const {
  return _impl_.bar_width_;
}
inline uint32_t BarDef::bar_width() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BarDef.bar_width)
  return _internal_bar_width();
}
inline void BarDef::_internal_set_bar_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bar_width_ = value;
}
inline void BarDef::set_bar_width(uint32_t value) {
  _internal_set_bar_width(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BarDef.bar_width)
}

// -------------------------------------------------------------------

// HistogramDef

// .epoch_proto.ChartDef chart_def = 1;
inline bool HistogramDef::_internal_has_chart_def() const {
  return this != internal_default_instance() && _impl_.chart_def_ != nullptr;
}
inline bool HistogramDef::has_chart_def() const {
  return _internal_has_chart_def();
}
inline void HistogramDef::clear_chart_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
}
inline const ::epoch_proto::ChartDef& HistogramDef::_internal_chart_def() const {
  const ::epoch_proto::ChartDef* p = _impl_.chart_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::ChartDef&>(
      ::epoch_proto::_ChartDef_default_instance_);
}
inline const ::epoch_proto::ChartDef& HistogramDef::chart_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.HistogramDef.chart_def)
  return _internal_chart_def();
}
inline void HistogramDef::unsafe_arena_set_allocated_chart_def(
    ::epoch_proto::ChartDef* chart_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chart_def_);
  }
  _impl_.chart_def_ = chart_def;
  if (chart_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.HistogramDef.chart_def)
}
inline ::epoch_proto::ChartDef* HistogramDef::release_chart_def() {
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::ChartDef* HistogramDef::unsafe_arena_release_chart_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.HistogramDef.chart_def)
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
  return temp;
}
inline ::epoch_proto::ChartDef* HistogramDef::_internal_mutable_chart_def() {
  
  if (_impl_.chart_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::ChartDef>(GetArenaForAllocation());
    _impl_.chart_def_ = p;
  }
  return _impl_.chart_def_;
}
inline ::epoch_proto::ChartDef* HistogramDef::mutable_chart_def() {
  ::epoch_proto::ChartDef* _msg = _internal_mutable_chart_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.HistogramDef.chart_def)
  return _msg;
}
inline void HistogramDef::set_allocated_chart_def(::epoch_proto::ChartDef* chart_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chart_def_;
  }
  if (chart_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chart_def);
    if (message_arena != submessage_arena) {
      chart_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chart_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chart_def_ = chart_def;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.HistogramDef.chart_def)
}

// .epoch_proto.Array data = 2;
inline bool HistogramDef::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool HistogramDef::has_data() const {
  return _internal_has_data();
}
inline const ::epoch_proto::Array& HistogramDef::_internal_data() const {
  const ::epoch_proto::Array* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::Array&>(
      ::epoch_proto::_Array_default_instance_);
}
inline const ::epoch_proto::Array& HistogramDef::data() const {
  // @@protoc_insertion_point(field_get:epoch_proto.HistogramDef.data)
  return _internal_data();
}
inline void HistogramDef::unsafe_arena_set_allocated_data(
    ::epoch_proto::Array* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.HistogramDef.data)
}
inline ::epoch_proto::Array* HistogramDef::release_data() {
  
  ::epoch_proto::Array* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::Array* HistogramDef::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:epoch_proto.HistogramDef.data)
  
  ::epoch_proto::Array* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::epoch_proto::Array* HistogramDef::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::Array>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::epoch_proto::Array* HistogramDef::mutable_data() {
  ::epoch_proto::Array* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:epoch_proto.HistogramDef.data)
  return _msg;
}
inline void HistogramDef::set_allocated_data(::epoch_proto::Array* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.HistogramDef.data)
}

// repeated .epoch_proto.StraightLineDef straight_lines = 3;
inline int HistogramDef::_internal_straight_lines_size() const {
  return _impl_.straight_lines_.size();
}
inline int HistogramDef::straight_lines_size() const {
  return _internal_straight_lines_size();
}
inline void HistogramDef::clear_straight_lines() {
  _impl_.straight_lines_.Clear();
}
inline ::epoch_proto::StraightLineDef* HistogramDef::mutable_straight_lines(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.HistogramDef.straight_lines)
  return _impl_.straight_lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >*
HistogramDef::mutable_straight_lines() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.HistogramDef.straight_lines)
  return &_impl_.straight_lines_;
}
inline const ::epoch_proto::StraightLineDef& HistogramDef::_internal_straight_lines(int index) const {
  return _impl_.straight_lines_.Get(index);
}
inline const ::epoch_proto::StraightLineDef& HistogramDef::straight_lines(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.HistogramDef.straight_lines)
  return _internal_straight_lines(index);
}
inline ::epoch_proto::StraightLineDef* HistogramDef::_internal_add_straight_lines() {
  return _impl_.straight_lines_.Add();
}
inline ::epoch_proto::StraightLineDef* HistogramDef::add_straight_lines() {
  ::epoch_proto::StraightLineDef* _add = _internal_add_straight_lines();
  // @@protoc_insertion_point(field_add:epoch_proto.HistogramDef.straight_lines)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::StraightLineDef >&
HistogramDef::straight_lines() const {
  // @@protoc_insertion_point(field_list:epoch_proto.HistogramDef.straight_lines)
  return _impl_.straight_lines_;
}

// optional uint32 bins_count = 4;
inline bool HistogramDef::_internal_has_bins_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HistogramDef::has_bins_count() const {
  return _internal_has_bins_count();
}
inline void HistogramDef::clear_bins_count() {
  _impl_.bins_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t HistogramDef::_internal_bins_count() const {
  return _impl_.bins_count_;
}
inline uint32_t HistogramDef::bins_count() const {
  // @@protoc_insertion_point(field_get:epoch_proto.HistogramDef.bins_count)
  return _internal_bins_count();
}
inline void HistogramDef::_internal_set_bins_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bins_count_ = value;
}
inline void HistogramDef::set_bins_count(uint32_t value) {
  _internal_set_bins_count(value);
  // @@protoc_insertion_point(field_set:epoch_proto.HistogramDef.bins_count)
}

// -------------------------------------------------------------------

// BoxPlotDataPoint

// double low = 1;
inline void BoxPlotDataPoint::clear_low() {
  _impl_.low_ = 0;
}
inline double BoxPlotDataPoint::_internal_low() const {
  return _impl_.low_;
}
inline double BoxPlotDataPoint::low() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDataPoint.low)
  return _internal_low();
}
inline void BoxPlotDataPoint::_internal_set_low(double value) {
  
  _impl_.low_ = value;
}
inline void BoxPlotDataPoint::set_low(double value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BoxPlotDataPoint.low)
}

// double q1 = 2;
inline void BoxPlotDataPoint::clear_q1() {
  _impl_.q1_ = 0;
}
inline double BoxPlotDataPoint::_internal_q1() const {
  return _impl_.q1_;
}
inline double BoxPlotDataPoint::q1() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDataPoint.q1)
  return _internal_q1();
}
inline void BoxPlotDataPoint::_internal_set_q1(double value) {
  
  _impl_.q1_ = value;
}
inline void BoxPlotDataPoint::set_q1(double value) {
  _internal_set_q1(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BoxPlotDataPoint.q1)
}

// double median = 3;
inline void BoxPlotDataPoint::clear_median() {
  _impl_.median_ = 0;
}
inline double BoxPlotDataPoint::_internal_median() const {
  return _impl_.median_;
}
inline double BoxPlotDataPoint::median() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDataPoint.median)
  return _internal_median();
}
inline void BoxPlotDataPoint::_internal_set_median(double value) {
  
  _impl_.median_ = value;
}
inline void BoxPlotDataPoint::set_median(double value) {
  _internal_set_median(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BoxPlotDataPoint.median)
}

// double q3 = 4;
inline void BoxPlotDataPoint::clear_q3() {
  _impl_.q3_ = 0;
}
inline double BoxPlotDataPoint::_internal_q3() const {
  return _impl_.q3_;
}
inline double BoxPlotDataPoint::q3() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDataPoint.q3)
  return _internal_q3();
}
inline void BoxPlotDataPoint::_internal_set_q3(double value) {
  
  _impl_.q3_ = value;
}
inline void BoxPlotDataPoint::set_q3(double value) {
  _internal_set_q3(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BoxPlotDataPoint.q3)
}

// double high = 5;
inline void BoxPlotDataPoint::clear_high() {
  _impl_.high_ = 0;
}
inline double BoxPlotDataPoint::_internal_high() const {
  return _impl_.high_;
}
inline double BoxPlotDataPoint::high() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDataPoint.high)
  return _internal_high();
}
inline void BoxPlotDataPoint::_internal_set_high(double value) {
  
  _impl_.high_ = value;
}
inline void BoxPlotDataPoint::set_high(double value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BoxPlotDataPoint.high)
}

// -------------------------------------------------------------------

// BoxPlotOutlier

// uint64 category_index = 1;
inline void BoxPlotOutlier::clear_category_index() {
  _impl_.category_index_ = uint64_t{0u};
}
inline uint64_t BoxPlotOutlier::_internal_category_index() const {
  return _impl_.category_index_;
}
inline uint64_t BoxPlotOutlier::category_index() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotOutlier.category_index)
  return _internal_category_index();
}
inline void BoxPlotOutlier::_internal_set_category_index(uint64_t value) {
  
  _impl_.category_index_ = value;
}
inline void BoxPlotOutlier::set_category_index(uint64_t value) {
  _internal_set_category_index(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BoxPlotOutlier.category_index)
}

// double value = 2;
inline void BoxPlotOutlier::clear_value() {
  _impl_.value_ = 0;
}
inline double BoxPlotOutlier::_internal_value() const {
  return _impl_.value_;
}
inline double BoxPlotOutlier::value() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotOutlier.value)
  return _internal_value();
}
inline void BoxPlotOutlier::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void BoxPlotOutlier::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:epoch_proto.BoxPlotOutlier.value)
}

// -------------------------------------------------------------------

// BoxPlotDataPointDef

// repeated .epoch_proto.BoxPlotOutlier outliers = 1;
inline int BoxPlotDataPointDef::_internal_outliers_size() const {
  return _impl_.outliers_.size();
}
inline int BoxPlotDataPointDef::outliers_size() const {
  return _internal_outliers_size();
}
inline void BoxPlotDataPointDef::clear_outliers() {
  _impl_.outliers_.Clear();
}
inline ::epoch_proto::BoxPlotOutlier* BoxPlotDataPointDef::mutable_outliers(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.BoxPlotDataPointDef.outliers)
  return _impl_.outliers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotOutlier >*
BoxPlotDataPointDef::mutable_outliers() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.BoxPlotDataPointDef.outliers)
  return &_impl_.outliers_;
}
inline const ::epoch_proto::BoxPlotOutlier& BoxPlotDataPointDef::_internal_outliers(int index) const {
  return _impl_.outliers_.Get(index);
}
inline const ::epoch_proto::BoxPlotOutlier& BoxPlotDataPointDef::outliers(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDataPointDef.outliers)
  return _internal_outliers(index);
}
inline ::epoch_proto::BoxPlotOutlier* BoxPlotDataPointDef::_internal_add_outliers() {
  return _impl_.outliers_.Add();
}
inline ::epoch_proto::BoxPlotOutlier* BoxPlotDataPointDef::add_outliers() {
  ::epoch_proto::BoxPlotOutlier* _add = _internal_add_outliers();
  // @@protoc_insertion_point(field_add:epoch_proto.BoxPlotDataPointDef.outliers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotOutlier >&
BoxPlotDataPointDef::outliers() const {
  // @@protoc_insertion_point(field_list:epoch_proto.BoxPlotDataPointDef.outliers)
  return _impl_.outliers_;
}

// repeated .epoch_proto.BoxPlotDataPoint points = 2;
inline int BoxPlotDataPointDef::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int BoxPlotDataPointDef::points_size() const {
  return _internal_points_size();
}
inline void BoxPlotDataPointDef::clear_points() {
  _impl_.points_.Clear();
}
inline ::epoch_proto::BoxPlotDataPoint* BoxPlotDataPointDef::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.BoxPlotDataPointDef.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotDataPoint >*
BoxPlotDataPointDef::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.BoxPlotDataPointDef.points)
  return &_impl_.points_;
}
inline const ::epoch_proto::BoxPlotDataPoint& BoxPlotDataPointDef::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::epoch_proto::BoxPlotDataPoint& BoxPlotDataPointDef::points(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDataPointDef.points)
  return _internal_points(index);
}
inline ::epoch_proto::BoxPlotDataPoint* BoxPlotDataPointDef::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::epoch_proto::BoxPlotDataPoint* BoxPlotDataPointDef::add_points() {
  ::epoch_proto::BoxPlotDataPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:epoch_proto.BoxPlotDataPointDef.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::BoxPlotDataPoint >&
BoxPlotDataPointDef::points() const {
  // @@protoc_insertion_point(field_list:epoch_proto.BoxPlotDataPointDef.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// BoxPlotDef

// .epoch_proto.ChartDef chart_def = 1;
inline bool BoxPlotDef::_internal_has_chart_def() const {
  return this != internal_default_instance() && _impl_.chart_def_ != nullptr;
}
inline bool BoxPlotDef::has_chart_def() const {
  return _internal_has_chart_def();
}
inline void BoxPlotDef::clear_chart_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
}
inline const ::epoch_proto::ChartDef& BoxPlotDef::_internal_chart_def() const {
  const ::epoch_proto::ChartDef* p = _impl_.chart_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::ChartDef&>(
      ::epoch_proto::_ChartDef_default_instance_);
}
inline const ::epoch_proto::ChartDef& BoxPlotDef::chart_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDef.chart_def)
  return _internal_chart_def();
}
inline void BoxPlotDef::unsafe_arena_set_allocated_chart_def(
    ::epoch_proto::ChartDef* chart_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chart_def_);
  }
  _impl_.chart_def_ = chart_def;
  if (chart_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.BoxPlotDef.chart_def)
}
inline ::epoch_proto::ChartDef* BoxPlotDef::release_chart_def() {
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::ChartDef* BoxPlotDef::unsafe_arena_release_chart_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.BoxPlotDef.chart_def)
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
  return temp;
}
inline ::epoch_proto::ChartDef* BoxPlotDef::_internal_mutable_chart_def() {
  
  if (_impl_.chart_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::ChartDef>(GetArenaForAllocation());
    _impl_.chart_def_ = p;
  }
  return _impl_.chart_def_;
}
inline ::epoch_proto::ChartDef* BoxPlotDef::mutable_chart_def() {
  ::epoch_proto::ChartDef* _msg = _internal_mutable_chart_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.BoxPlotDef.chart_def)
  return _msg;
}
inline void BoxPlotDef::set_allocated_chart_def(::epoch_proto::ChartDef* chart_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chart_def_;
  }
  if (chart_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chart_def);
    if (message_arena != submessage_arena) {
      chart_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chart_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chart_def_ = chart_def;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.BoxPlotDef.chart_def)
}

// .epoch_proto.BoxPlotDataPointDef data = 2;
inline bool BoxPlotDef::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool BoxPlotDef::has_data() const {
  return _internal_has_data();
}
inline void BoxPlotDef::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::epoch_proto::BoxPlotDataPointDef& BoxPlotDef::_internal_data() const {
  const ::epoch_proto::BoxPlotDataPointDef* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::BoxPlotDataPointDef&>(
      ::epoch_proto::_BoxPlotDataPointDef_default_instance_);
}
inline const ::epoch_proto::BoxPlotDataPointDef& BoxPlotDef::data() const {
  // @@protoc_insertion_point(field_get:epoch_proto.BoxPlotDef.data)
  return _internal_data();
}
inline void BoxPlotDef::unsafe_arena_set_allocated_data(
    ::epoch_proto::BoxPlotDataPointDef* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.BoxPlotDef.data)
}
inline ::epoch_proto::BoxPlotDataPointDef* BoxPlotDef::release_data() {
  
  ::epoch_proto::BoxPlotDataPointDef* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::BoxPlotDataPointDef* BoxPlotDef::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:epoch_proto.BoxPlotDef.data)
  
  ::epoch_proto::BoxPlotDataPointDef* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::epoch_proto::BoxPlotDataPointDef* BoxPlotDef::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::BoxPlotDataPointDef>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::epoch_proto::BoxPlotDataPointDef* BoxPlotDef::mutable_data() {
  ::epoch_proto::BoxPlotDataPointDef* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:epoch_proto.BoxPlotDef.data)
  return _msg;
}
inline void BoxPlotDef::set_allocated_data(::epoch_proto::BoxPlotDataPointDef* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.BoxPlotDef.data)
}

// -------------------------------------------------------------------

// XRangePoint

// int64 x = 1;
inline void XRangePoint::clear_x() {
  _impl_.x_ = int64_t{0};
}
inline int64_t XRangePoint::_internal_x() const {
  return _impl_.x_;
}
inline int64_t XRangePoint::x() const {
  // @@protoc_insertion_point(field_get:epoch_proto.XRangePoint.x)
  return _internal_x();
}
inline void XRangePoint::_internal_set_x(int64_t value) {
  
  _impl_.x_ = value;
}
inline void XRangePoint::set_x(int64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:epoch_proto.XRangePoint.x)
}

// int64 x2 = 2;
inline void XRangePoint::clear_x2() {
  _impl_.x2_ = int64_t{0};
}
inline int64_t XRangePoint::_internal_x2() const {
  return _impl_.x2_;
}
inline int64_t XRangePoint::x2() const {
  // @@protoc_insertion_point(field_get:epoch_proto.XRangePoint.x2)
  return _internal_x2();
}
inline void XRangePoint::_internal_set_x2(int64_t value) {
  
  _impl_.x2_ = value;
}
inline void XRangePoint::set_x2(int64_t value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:epoch_proto.XRangePoint.x2)
}

// uint64 y = 3;
inline void XRangePoint::clear_y() {
  _impl_.y_ = uint64_t{0u};
}
inline uint64_t XRangePoint::_internal_y() const {
  return _impl_.y_;
}
inline uint64_t XRangePoint::y() const {
  // @@protoc_insertion_point(field_get:epoch_proto.XRangePoint.y)
  return _internal_y();
}
inline void XRangePoint::_internal_set_y(uint64_t value) {
  
  _impl_.y_ = value;
}
inline void XRangePoint::set_y(uint64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:epoch_proto.XRangePoint.y)
}

// bool is_long = 4;
inline void XRangePoint::clear_is_long() {
  _impl_.is_long_ = false;
}
inline bool XRangePoint::_internal_is_long() const {
  return _impl_.is_long_;
}
inline bool XRangePoint::is_long() const {
  // @@protoc_insertion_point(field_get:epoch_proto.XRangePoint.is_long)
  return _internal_is_long();
}
inline void XRangePoint::_internal_set_is_long(bool value) {
  
  _impl_.is_long_ = value;
}
inline void XRangePoint::set_is_long(bool value) {
  _internal_set_is_long(value);
  // @@protoc_insertion_point(field_set:epoch_proto.XRangePoint.is_long)
}

// -------------------------------------------------------------------

// XRangeDef

// .epoch_proto.ChartDef chart_def = 1;
inline bool XRangeDef::_internal_has_chart_def() const {
  return this != internal_default_instance() && _impl_.chart_def_ != nullptr;
}
inline bool XRangeDef::has_chart_def() const {
  return _internal_has_chart_def();
}
inline void XRangeDef::clear_chart_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
}
inline const ::epoch_proto::ChartDef& XRangeDef::_internal_chart_def() const {
  const ::epoch_proto::ChartDef* p = _impl_.chart_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::ChartDef&>(
      ::epoch_proto::_ChartDef_default_instance_);
}
inline const ::epoch_proto::ChartDef& XRangeDef::chart_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.XRangeDef.chart_def)
  return _internal_chart_def();
}
inline void XRangeDef::unsafe_arena_set_allocated_chart_def(
    ::epoch_proto::ChartDef* chart_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chart_def_);
  }
  _impl_.chart_def_ = chart_def;
  if (chart_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.XRangeDef.chart_def)
}
inline ::epoch_proto::ChartDef* XRangeDef::release_chart_def() {
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::ChartDef* XRangeDef::unsafe_arena_release_chart_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.XRangeDef.chart_def)
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
  return temp;
}
inline ::epoch_proto::ChartDef* XRangeDef::_internal_mutable_chart_def() {
  
  if (_impl_.chart_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::ChartDef>(GetArenaForAllocation());
    _impl_.chart_def_ = p;
  }
  return _impl_.chart_def_;
}
inline ::epoch_proto::ChartDef* XRangeDef::mutable_chart_def() {
  ::epoch_proto::ChartDef* _msg = _internal_mutable_chart_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.XRangeDef.chart_def)
  return _msg;
}
inline void XRangeDef::set_allocated_chart_def(::epoch_proto::ChartDef* chart_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chart_def_;
  }
  if (chart_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chart_def);
    if (message_arena != submessage_arena) {
      chart_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chart_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chart_def_ = chart_def;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.XRangeDef.chart_def)
}

// repeated string categories = 2;
inline int XRangeDef::_internal_categories_size() const {
  return _impl_.categories_.size();
}
inline int XRangeDef::categories_size() const {
  return _internal_categories_size();
}
inline void XRangeDef::clear_categories() {
  _impl_.categories_.Clear();
}
inline std::string* XRangeDef::add_categories() {
  std::string* _s = _internal_add_categories();
  // @@protoc_insertion_point(field_add_mutable:epoch_proto.XRangeDef.categories)
  return _s;
}
inline const std::string& XRangeDef::_internal_categories(int index) const {
  return _impl_.categories_.Get(index);
}
inline const std::string& XRangeDef::categories(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.XRangeDef.categories)
  return _internal_categories(index);
}
inline std::string* XRangeDef::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.XRangeDef.categories)
  return _impl_.categories_.Mutable(index);
}
inline void XRangeDef::set_categories(int index, const std::string& value) {
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:epoch_proto.XRangeDef.categories)
}
inline void XRangeDef::set_categories(int index, std::string&& value) {
  _impl_.categories_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:epoch_proto.XRangeDef.categories)
}
inline void XRangeDef::set_categories(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:epoch_proto.XRangeDef.categories)
}
inline void XRangeDef::set_categories(int index, const char* value, size_t size) {
  _impl_.categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:epoch_proto.XRangeDef.categories)
}
inline std::string* XRangeDef::_internal_add_categories() {
  return _impl_.categories_.Add();
}
inline void XRangeDef::add_categories(const std::string& value) {
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:epoch_proto.XRangeDef.categories)
}
inline void XRangeDef::add_categories(std::string&& value) {
  _impl_.categories_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:epoch_proto.XRangeDef.categories)
}
inline void XRangeDef::add_categories(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:epoch_proto.XRangeDef.categories)
}
inline void XRangeDef::add_categories(const char* value, size_t size) {
  _impl_.categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:epoch_proto.XRangeDef.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
XRangeDef::categories() const {
  // @@protoc_insertion_point(field_list:epoch_proto.XRangeDef.categories)
  return _impl_.categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
XRangeDef::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.XRangeDef.categories)
  return &_impl_.categories_;
}

// repeated .epoch_proto.XRangePoint points = 3;
inline int XRangeDef::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int XRangeDef::points_size() const {
  return _internal_points_size();
}
inline void XRangeDef::clear_points() {
  _impl_.points_.Clear();
}
inline ::epoch_proto::XRangePoint* XRangeDef::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.XRangeDef.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::XRangePoint >*
XRangeDef::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.XRangeDef.points)
  return &_impl_.points_;
}
inline const ::epoch_proto::XRangePoint& XRangeDef::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::epoch_proto::XRangePoint& XRangeDef::points(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.XRangeDef.points)
  return _internal_points(index);
}
inline ::epoch_proto::XRangePoint* XRangeDef::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::epoch_proto::XRangePoint* XRangeDef::add_points() {
  ::epoch_proto::XRangePoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:epoch_proto.XRangeDef.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::XRangePoint >&
XRangeDef::points() const {
  // @@protoc_insertion_point(field_list:epoch_proto.XRangeDef.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// PieData

// string name = 1;
inline void PieData::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PieData::name() const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PieData::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.PieData.name)
}
inline std::string* PieData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:epoch_proto.PieData.name)
  return _s;
}
inline const std::string& PieData::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PieData::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PieData::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PieData::release_name() {
  // @@protoc_insertion_point(field_release:epoch_proto.PieData.name)
  return _impl_.name_.Release();
}
inline void PieData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.PieData.name)
}

// double y = 2;
inline void PieData::clear_y() {
  _impl_.y_ = 0;
}
inline double PieData::_internal_y() const {
  return _impl_.y_;
}
inline double PieData::y() const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieData.y)
  return _internal_y();
}
inline void PieData::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void PieData::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:epoch_proto.PieData.y)
}

// -------------------------------------------------------------------

// PieDataDef

// string name = 1;
inline void PieDataDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PieDataDef::name() const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieDataDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PieDataDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.PieDataDef.name)
}
inline std::string* PieDataDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:epoch_proto.PieDataDef.name)
  return _s;
}
inline const std::string& PieDataDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PieDataDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PieDataDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PieDataDef::release_name() {
  // @@protoc_insertion_point(field_release:epoch_proto.PieDataDef.name)
  return _impl_.name_.Release();
}
inline void PieDataDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.PieDataDef.name)
}

// repeated .epoch_proto.PieData points = 2;
inline int PieDataDef::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int PieDataDef::points_size() const {
  return _internal_points_size();
}
inline void PieDataDef::clear_points() {
  _impl_.points_.Clear();
}
inline ::epoch_proto::PieData* PieDataDef::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.PieDataDef.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieData >*
PieDataDef::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.PieDataDef.points)
  return &_impl_.points_;
}
inline const ::epoch_proto::PieData& PieDataDef::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::epoch_proto::PieData& PieDataDef::points(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieDataDef.points)
  return _internal_points(index);
}
inline ::epoch_proto::PieData* PieDataDef::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::epoch_proto::PieData* PieDataDef::add_points() {
  ::epoch_proto::PieData* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:epoch_proto.PieDataDef.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieData >&
PieDataDef::points() const {
  // @@protoc_insertion_point(field_list:epoch_proto.PieDataDef.points)
  return _impl_.points_;
}

// string size = 3;
inline void PieDataDef::clear_size() {
  _impl_.size_.ClearToEmpty();
}
inline const std::string& PieDataDef::size() const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieDataDef.size)
  return _internal_size();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PieDataDef::set_size(ArgT0&& arg0, ArgT... args) {
 
 _impl_.size_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.PieDataDef.size)
}
inline std::string* PieDataDef::mutable_size() {
  std::string* _s = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:epoch_proto.PieDataDef.size)
  return _s;
}
inline const std::string& PieDataDef::_internal_size() const {
  return _impl_.size_.Get();
}
inline void PieDataDef::_internal_set_size(const std::string& value) {
  
  _impl_.size_.Set(value, GetArenaForAllocation());
}
inline std::string* PieDataDef::_internal_mutable_size() {
  
  return _impl_.size_.Mutable(GetArenaForAllocation());
}
inline std::string* PieDataDef::release_size() {
  // @@protoc_insertion_point(field_release:epoch_proto.PieDataDef.size)
  return _impl_.size_.Release();
}
inline void PieDataDef::set_allocated_size(std::string* size) {
  if (size != nullptr) {
    
  } else {
    
  }
  _impl_.size_.SetAllocated(size, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.size_.IsDefault()) {
    _impl_.size_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.PieDataDef.size)
}

// optional string inner_size = 4;
inline bool PieDataDef::_internal_has_inner_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PieDataDef::has_inner_size() const {
  return _internal_has_inner_size();
}
inline void PieDataDef::clear_inner_size() {
  _impl_.inner_size_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PieDataDef::inner_size() const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieDataDef.inner_size)
  return _internal_inner_size();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PieDataDef::set_inner_size(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.inner_size_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:epoch_proto.PieDataDef.inner_size)
}
inline std::string* PieDataDef::mutable_inner_size() {
  std::string* _s = _internal_mutable_inner_size();
  // @@protoc_insertion_point(field_mutable:epoch_proto.PieDataDef.inner_size)
  return _s;
}
inline const std::string& PieDataDef::_internal_inner_size() const {
  return _impl_.inner_size_.Get();
}
inline void PieDataDef::_internal_set_inner_size(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.inner_size_.Set(value, GetArenaForAllocation());
}
inline std::string* PieDataDef::_internal_mutable_inner_size() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.inner_size_.Mutable(GetArenaForAllocation());
}
inline std::string* PieDataDef::release_inner_size() {
  // @@protoc_insertion_point(field_release:epoch_proto.PieDataDef.inner_size)
  if (!_internal_has_inner_size()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.inner_size_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.inner_size_.IsDefault()) {
    _impl_.inner_size_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PieDataDef::set_allocated_inner_size(std::string* inner_size) {
  if (inner_size != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.inner_size_.SetAllocated(inner_size, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.inner_size_.IsDefault()) {
    _impl_.inner_size_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.PieDataDef.inner_size)
}

// -------------------------------------------------------------------

// PieDef

// .epoch_proto.ChartDef chart_def = 1;
inline bool PieDef::_internal_has_chart_def() const {
  return this != internal_default_instance() && _impl_.chart_def_ != nullptr;
}
inline bool PieDef::has_chart_def() const {
  return _internal_has_chart_def();
}
inline void PieDef::clear_chart_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
}
inline const ::epoch_proto::ChartDef& PieDef::_internal_chart_def() const {
  const ::epoch_proto::ChartDef* p = _impl_.chart_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::epoch_proto::ChartDef&>(
      ::epoch_proto::_ChartDef_default_instance_);
}
inline const ::epoch_proto::ChartDef& PieDef::chart_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieDef.chart_def)
  return _internal_chart_def();
}
inline void PieDef::unsafe_arena_set_allocated_chart_def(
    ::epoch_proto::ChartDef* chart_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chart_def_);
  }
  _impl_.chart_def_ = chart_def;
  if (chart_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.PieDef.chart_def)
}
inline ::epoch_proto::ChartDef* PieDef::release_chart_def() {
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::epoch_proto::ChartDef* PieDef::unsafe_arena_release_chart_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.PieDef.chart_def)
  
  ::epoch_proto::ChartDef* temp = _impl_.chart_def_;
  _impl_.chart_def_ = nullptr;
  return temp;
}
inline ::epoch_proto::ChartDef* PieDef::_internal_mutable_chart_def() {
  
  if (_impl_.chart_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::epoch_proto::ChartDef>(GetArenaForAllocation());
    _impl_.chart_def_ = p;
  }
  return _impl_.chart_def_;
}
inline ::epoch_proto::ChartDef* PieDef::mutable_chart_def() {
  ::epoch_proto::ChartDef* _msg = _internal_mutable_chart_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.PieDef.chart_def)
  return _msg;
}
inline void PieDef::set_allocated_chart_def(::epoch_proto::ChartDef* chart_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chart_def_;
  }
  if (chart_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chart_def);
    if (message_arena != submessage_arena) {
      chart_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chart_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chart_def_ = chart_def;
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.PieDef.chart_def)
}

// repeated .epoch_proto.PieDataDef data = 2;
inline int PieDef::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int PieDef::data_size() const {
  return _internal_data_size();
}
inline void PieDef::clear_data() {
  _impl_.data_.Clear();
}
inline ::epoch_proto::PieDataDef* PieDef::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:epoch_proto.PieDef.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieDataDef >*
PieDef::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:epoch_proto.PieDef.data)
  return &_impl_.data_;
}
inline const ::epoch_proto::PieDataDef& PieDef::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::epoch_proto::PieDataDef& PieDef::data(int index) const {
  // @@protoc_insertion_point(field_get:epoch_proto.PieDef.data)
  return _internal_data(index);
}
inline ::epoch_proto::PieDataDef* PieDef::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::epoch_proto::PieDataDef* PieDef::add_data() {
  ::epoch_proto::PieDataDef* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:epoch_proto.PieDef.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::epoch_proto::PieDataDef >&
PieDef::data() const {
  // @@protoc_insertion_point(field_list:epoch_proto.PieDef.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// Chart

// .epoch_proto.LinesDef lines_def = 1;
inline bool Chart::_internal_has_lines_def() const {
  return chart_type_case() == kLinesDef;
}
inline bool Chart::has_lines_def() const {
  return _internal_has_lines_def();
}
inline void Chart::set_has_lines_def() {
  _impl_._oneof_case_[0] = kLinesDef;
}
inline void Chart::clear_lines_def() {
  if (_internal_has_lines_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.chart_type_.lines_def_;
    }
    clear_has_chart_type();
  }
}
inline ::epoch_proto::LinesDef* Chart::release_lines_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.Chart.lines_def)
  if (_internal_has_lines_def()) {
    clear_has_chart_type();
    ::epoch_proto::LinesDef* temp = _impl_.chart_type_.lines_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.chart_type_.lines_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::epoch_proto::LinesDef& Chart::_internal_lines_def() const {
  return _internal_has_lines_def()
      ? *_impl_.chart_type_.lines_def_
      : reinterpret_cast< ::epoch_proto::LinesDef&>(::epoch_proto::_LinesDef_default_instance_);
}
inline const ::epoch_proto::LinesDef& Chart::lines_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Chart.lines_def)
  return _internal_lines_def();
}
inline ::epoch_proto::LinesDef* Chart::unsafe_arena_release_lines_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:epoch_proto.Chart.lines_def)
  if (_internal_has_lines_def()) {
    clear_has_chart_type();
    ::epoch_proto::LinesDef* temp = _impl_.chart_type_.lines_def_;
    _impl_.chart_type_.lines_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Chart::unsafe_arena_set_allocated_lines_def(::epoch_proto::LinesDef* lines_def) {
  clear_chart_type();
  if (lines_def) {
    set_has_lines_def();
    _impl_.chart_type_.lines_def_ = lines_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Chart.lines_def)
}
inline ::epoch_proto::LinesDef* Chart::_internal_mutable_lines_def() {
  if (!_internal_has_lines_def()) {
    clear_chart_type();
    set_has_lines_def();
    _impl_.chart_type_.lines_def_ = CreateMaybeMessage< ::epoch_proto::LinesDef >(GetArenaForAllocation());
  }
  return _impl_.chart_type_.lines_def_;
}
inline ::epoch_proto::LinesDef* Chart::mutable_lines_def() {
  ::epoch_proto::LinesDef* _msg = _internal_mutable_lines_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Chart.lines_def)
  return _msg;
}

// .epoch_proto.HeatMapDef heat_map_def = 2;
inline bool Chart::_internal_has_heat_map_def() const {
  return chart_type_case() == kHeatMapDef;
}
inline bool Chart::has_heat_map_def() const {
  return _internal_has_heat_map_def();
}
inline void Chart::set_has_heat_map_def() {
  _impl_._oneof_case_[0] = kHeatMapDef;
}
inline void Chart::clear_heat_map_def() {
  if (_internal_has_heat_map_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.chart_type_.heat_map_def_;
    }
    clear_has_chart_type();
  }
}
inline ::epoch_proto::HeatMapDef* Chart::release_heat_map_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.Chart.heat_map_def)
  if (_internal_has_heat_map_def()) {
    clear_has_chart_type();
    ::epoch_proto::HeatMapDef* temp = _impl_.chart_type_.heat_map_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.chart_type_.heat_map_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::epoch_proto::HeatMapDef& Chart::_internal_heat_map_def() const {
  return _internal_has_heat_map_def()
      ? *_impl_.chart_type_.heat_map_def_
      : reinterpret_cast< ::epoch_proto::HeatMapDef&>(::epoch_proto::_HeatMapDef_default_instance_);
}
inline const ::epoch_proto::HeatMapDef& Chart::heat_map_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Chart.heat_map_def)
  return _internal_heat_map_def();
}
inline ::epoch_proto::HeatMapDef* Chart::unsafe_arena_release_heat_map_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:epoch_proto.Chart.heat_map_def)
  if (_internal_has_heat_map_def()) {
    clear_has_chart_type();
    ::epoch_proto::HeatMapDef* temp = _impl_.chart_type_.heat_map_def_;
    _impl_.chart_type_.heat_map_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Chart::unsafe_arena_set_allocated_heat_map_def(::epoch_proto::HeatMapDef* heat_map_def) {
  clear_chart_type();
  if (heat_map_def) {
    set_has_heat_map_def();
    _impl_.chart_type_.heat_map_def_ = heat_map_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Chart.heat_map_def)
}
inline ::epoch_proto::HeatMapDef* Chart::_internal_mutable_heat_map_def() {
  if (!_internal_has_heat_map_def()) {
    clear_chart_type();
    set_has_heat_map_def();
    _impl_.chart_type_.heat_map_def_ = CreateMaybeMessage< ::epoch_proto::HeatMapDef >(GetArenaForAllocation());
  }
  return _impl_.chart_type_.heat_map_def_;
}
inline ::epoch_proto::HeatMapDef* Chart::mutable_heat_map_def() {
  ::epoch_proto::HeatMapDef* _msg = _internal_mutable_heat_map_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Chart.heat_map_def)
  return _msg;
}

// .epoch_proto.BarDef bar_def = 3;
inline bool Chart::_internal_has_bar_def() const {
  return chart_type_case() == kBarDef;
}
inline bool Chart::has_bar_def() const {
  return _internal_has_bar_def();
}
inline void Chart::set_has_bar_def() {
  _impl_._oneof_case_[0] = kBarDef;
}
inline void Chart::clear_bar_def() {
  if (_internal_has_bar_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.chart_type_.bar_def_;
    }
    clear_has_chart_type();
  }
}
inline ::epoch_proto::BarDef* Chart::release_bar_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.Chart.bar_def)
  if (_internal_has_bar_def()) {
    clear_has_chart_type();
    ::epoch_proto::BarDef* temp = _impl_.chart_type_.bar_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.chart_type_.bar_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::epoch_proto::BarDef& Chart::_internal_bar_def() const {
  return _internal_has_bar_def()
      ? *_impl_.chart_type_.bar_def_
      : reinterpret_cast< ::epoch_proto::BarDef&>(::epoch_proto::_BarDef_default_instance_);
}
inline const ::epoch_proto::BarDef& Chart::bar_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Chart.bar_def)
  return _internal_bar_def();
}
inline ::epoch_proto::BarDef* Chart::unsafe_arena_release_bar_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:epoch_proto.Chart.bar_def)
  if (_internal_has_bar_def()) {
    clear_has_chart_type();
    ::epoch_proto::BarDef* temp = _impl_.chart_type_.bar_def_;
    _impl_.chart_type_.bar_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Chart::unsafe_arena_set_allocated_bar_def(::epoch_proto::BarDef* bar_def) {
  clear_chart_type();
  if (bar_def) {
    set_has_bar_def();
    _impl_.chart_type_.bar_def_ = bar_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Chart.bar_def)
}
inline ::epoch_proto::BarDef* Chart::_internal_mutable_bar_def() {
  if (!_internal_has_bar_def()) {
    clear_chart_type();
    set_has_bar_def();
    _impl_.chart_type_.bar_def_ = CreateMaybeMessage< ::epoch_proto::BarDef >(GetArenaForAllocation());
  }
  return _impl_.chart_type_.bar_def_;
}
inline ::epoch_proto::BarDef* Chart::mutable_bar_def() {
  ::epoch_proto::BarDef* _msg = _internal_mutable_bar_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Chart.bar_def)
  return _msg;
}

// .epoch_proto.HistogramDef histogram_def = 4;
inline bool Chart::_internal_has_histogram_def() const {
  return chart_type_case() == kHistogramDef;
}
inline bool Chart::has_histogram_def() const {
  return _internal_has_histogram_def();
}
inline void Chart::set_has_histogram_def() {
  _impl_._oneof_case_[0] = kHistogramDef;
}
inline void Chart::clear_histogram_def() {
  if (_internal_has_histogram_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.chart_type_.histogram_def_;
    }
    clear_has_chart_type();
  }
}
inline ::epoch_proto::HistogramDef* Chart::release_histogram_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.Chart.histogram_def)
  if (_internal_has_histogram_def()) {
    clear_has_chart_type();
    ::epoch_proto::HistogramDef* temp = _impl_.chart_type_.histogram_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.chart_type_.histogram_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::epoch_proto::HistogramDef& Chart::_internal_histogram_def() const {
  return _internal_has_histogram_def()
      ? *_impl_.chart_type_.histogram_def_
      : reinterpret_cast< ::epoch_proto::HistogramDef&>(::epoch_proto::_HistogramDef_default_instance_);
}
inline const ::epoch_proto::HistogramDef& Chart::histogram_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Chart.histogram_def)
  return _internal_histogram_def();
}
inline ::epoch_proto::HistogramDef* Chart::unsafe_arena_release_histogram_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:epoch_proto.Chart.histogram_def)
  if (_internal_has_histogram_def()) {
    clear_has_chart_type();
    ::epoch_proto::HistogramDef* temp = _impl_.chart_type_.histogram_def_;
    _impl_.chart_type_.histogram_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Chart::unsafe_arena_set_allocated_histogram_def(::epoch_proto::HistogramDef* histogram_def) {
  clear_chart_type();
  if (histogram_def) {
    set_has_histogram_def();
    _impl_.chart_type_.histogram_def_ = histogram_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Chart.histogram_def)
}
inline ::epoch_proto::HistogramDef* Chart::_internal_mutable_histogram_def() {
  if (!_internal_has_histogram_def()) {
    clear_chart_type();
    set_has_histogram_def();
    _impl_.chart_type_.histogram_def_ = CreateMaybeMessage< ::epoch_proto::HistogramDef >(GetArenaForAllocation());
  }
  return _impl_.chart_type_.histogram_def_;
}
inline ::epoch_proto::HistogramDef* Chart::mutable_histogram_def() {
  ::epoch_proto::HistogramDef* _msg = _internal_mutable_histogram_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Chart.histogram_def)
  return _msg;
}

// .epoch_proto.BoxPlotDef box_plot_def = 5;
inline bool Chart::_internal_has_box_plot_def() const {
  return chart_type_case() == kBoxPlotDef;
}
inline bool Chart::has_box_plot_def() const {
  return _internal_has_box_plot_def();
}
inline void Chart::set_has_box_plot_def() {
  _impl_._oneof_case_[0] = kBoxPlotDef;
}
inline void Chart::clear_box_plot_def() {
  if (_internal_has_box_plot_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.chart_type_.box_plot_def_;
    }
    clear_has_chart_type();
  }
}
inline ::epoch_proto::BoxPlotDef* Chart::release_box_plot_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.Chart.box_plot_def)
  if (_internal_has_box_plot_def()) {
    clear_has_chart_type();
    ::epoch_proto::BoxPlotDef* temp = _impl_.chart_type_.box_plot_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.chart_type_.box_plot_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::epoch_proto::BoxPlotDef& Chart::_internal_box_plot_def() const {
  return _internal_has_box_plot_def()
      ? *_impl_.chart_type_.box_plot_def_
      : reinterpret_cast< ::epoch_proto::BoxPlotDef&>(::epoch_proto::_BoxPlotDef_default_instance_);
}
inline const ::epoch_proto::BoxPlotDef& Chart::box_plot_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Chart.box_plot_def)
  return _internal_box_plot_def();
}
inline ::epoch_proto::BoxPlotDef* Chart::unsafe_arena_release_box_plot_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:epoch_proto.Chart.box_plot_def)
  if (_internal_has_box_plot_def()) {
    clear_has_chart_type();
    ::epoch_proto::BoxPlotDef* temp = _impl_.chart_type_.box_plot_def_;
    _impl_.chart_type_.box_plot_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Chart::unsafe_arena_set_allocated_box_plot_def(::epoch_proto::BoxPlotDef* box_plot_def) {
  clear_chart_type();
  if (box_plot_def) {
    set_has_box_plot_def();
    _impl_.chart_type_.box_plot_def_ = box_plot_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Chart.box_plot_def)
}
inline ::epoch_proto::BoxPlotDef* Chart::_internal_mutable_box_plot_def() {
  if (!_internal_has_box_plot_def()) {
    clear_chart_type();
    set_has_box_plot_def();
    _impl_.chart_type_.box_plot_def_ = CreateMaybeMessage< ::epoch_proto::BoxPlotDef >(GetArenaForAllocation());
  }
  return _impl_.chart_type_.box_plot_def_;
}
inline ::epoch_proto::BoxPlotDef* Chart::mutable_box_plot_def() {
  ::epoch_proto::BoxPlotDef* _msg = _internal_mutable_box_plot_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Chart.box_plot_def)
  return _msg;
}

// .epoch_proto.XRangeDef x_range_def = 6;
inline bool Chart::_internal_has_x_range_def() const {
  return chart_type_case() == kXRangeDef;
}
inline bool Chart::has_x_range_def() const {
  return _internal_has_x_range_def();
}
inline void Chart::set_has_x_range_def() {
  _impl_._oneof_case_[0] = kXRangeDef;
}
inline void Chart::clear_x_range_def() {
  if (_internal_has_x_range_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.chart_type_.x_range_def_;
    }
    clear_has_chart_type();
  }
}
inline ::epoch_proto::XRangeDef* Chart::release_x_range_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.Chart.x_range_def)
  if (_internal_has_x_range_def()) {
    clear_has_chart_type();
    ::epoch_proto::XRangeDef* temp = _impl_.chart_type_.x_range_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.chart_type_.x_range_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::epoch_proto::XRangeDef& Chart::_internal_x_range_def() const {
  return _internal_has_x_range_def()
      ? *_impl_.chart_type_.x_range_def_
      : reinterpret_cast< ::epoch_proto::XRangeDef&>(::epoch_proto::_XRangeDef_default_instance_);
}
inline const ::epoch_proto::XRangeDef& Chart::x_range_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Chart.x_range_def)
  return _internal_x_range_def();
}
inline ::epoch_proto::XRangeDef* Chart::unsafe_arena_release_x_range_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:epoch_proto.Chart.x_range_def)
  if (_internal_has_x_range_def()) {
    clear_has_chart_type();
    ::epoch_proto::XRangeDef* temp = _impl_.chart_type_.x_range_def_;
    _impl_.chart_type_.x_range_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Chart::unsafe_arena_set_allocated_x_range_def(::epoch_proto::XRangeDef* x_range_def) {
  clear_chart_type();
  if (x_range_def) {
    set_has_x_range_def();
    _impl_.chart_type_.x_range_def_ = x_range_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Chart.x_range_def)
}
inline ::epoch_proto::XRangeDef* Chart::_internal_mutable_x_range_def() {
  if (!_internal_has_x_range_def()) {
    clear_chart_type();
    set_has_x_range_def();
    _impl_.chart_type_.x_range_def_ = CreateMaybeMessage< ::epoch_proto::XRangeDef >(GetArenaForAllocation());
  }
  return _impl_.chart_type_.x_range_def_;
}
inline ::epoch_proto::XRangeDef* Chart::mutable_x_range_def() {
  ::epoch_proto::XRangeDef* _msg = _internal_mutable_x_range_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Chart.x_range_def)
  return _msg;
}

// .epoch_proto.PieDef pie_def = 7;
inline bool Chart::_internal_has_pie_def() const {
  return chart_type_case() == kPieDef;
}
inline bool Chart::has_pie_def() const {
  return _internal_has_pie_def();
}
inline void Chart::set_has_pie_def() {
  _impl_._oneof_case_[0] = kPieDef;
}
inline void Chart::clear_pie_def() {
  if (_internal_has_pie_def()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.chart_type_.pie_def_;
    }
    clear_has_chart_type();
  }
}
inline ::epoch_proto::PieDef* Chart::release_pie_def() {
  // @@protoc_insertion_point(field_release:epoch_proto.Chart.pie_def)
  if (_internal_has_pie_def()) {
    clear_has_chart_type();
    ::epoch_proto::PieDef* temp = _impl_.chart_type_.pie_def_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.chart_type_.pie_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::epoch_proto::PieDef& Chart::_internal_pie_def() const {
  return _internal_has_pie_def()
      ? *_impl_.chart_type_.pie_def_
      : reinterpret_cast< ::epoch_proto::PieDef&>(::epoch_proto::_PieDef_default_instance_);
}
inline const ::epoch_proto::PieDef& Chart::pie_def() const {
  // @@protoc_insertion_point(field_get:epoch_proto.Chart.pie_def)
  return _internal_pie_def();
}
inline ::epoch_proto::PieDef* Chart::unsafe_arena_release_pie_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:epoch_proto.Chart.pie_def)
  if (_internal_has_pie_def()) {
    clear_has_chart_type();
    ::epoch_proto::PieDef* temp = _impl_.chart_type_.pie_def_;
    _impl_.chart_type_.pie_def_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Chart::unsafe_arena_set_allocated_pie_def(::epoch_proto::PieDef* pie_def) {
  clear_chart_type();
  if (pie_def) {
    set_has_pie_def();
    _impl_.chart_type_.pie_def_ = pie_def;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:epoch_proto.Chart.pie_def)
}
inline ::epoch_proto::PieDef* Chart::_internal_mutable_pie_def() {
  if (!_internal_has_pie_def()) {
    clear_chart_type();
    set_has_pie_def();
    _impl_.chart_type_.pie_def_ = CreateMaybeMessage< ::epoch_proto::PieDef >(GetArenaForAllocation());
  }
  return _impl_.chart_type_.pie_def_;
}
inline ::epoch_proto::PieDef* Chart::mutable_pie_def() {
  ::epoch_proto::PieDef* _msg = _internal_mutable_pie_def();
  // @@protoc_insertion_point(field_mutable:epoch_proto.Chart.pie_def)
  return _msg;
}

inline bool Chart::has_chart_type() const {
  return chart_type_case() != CHART_TYPE_NOT_SET;
}
inline void Chart::clear_has_chart_type() {
  _impl_._oneof_case_[0] = CHART_TYPE_NOT_SET;
}
inline Chart::ChartTypeCase Chart::chart_type_case() const {
  return Chart::ChartTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace epoch_proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chart_5fdef_2eproto
