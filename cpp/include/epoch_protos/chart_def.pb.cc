// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chart_def.proto

#include "chart_def.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace epoch_proto {
PROTOBUF_CONSTEXPR AxisDef::AxisDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.categories_)*/{}
  , /*decltype(_impl_.label_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct AxisDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AxisDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AxisDefDefaultTypeInternal() {}
  union {
    AxisDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AxisDefDefaultTypeInternal _AxisDef_default_instance_;
PROTOBUF_CONSTEXPR ChartDef::ChartDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.category_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.y_axis_)*/nullptr
  , /*decltype(_impl_.x_axis_)*/nullptr
  , /*decltype(_impl_.type_)*/0} {}
struct ChartDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChartDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChartDefDefaultTypeInternal() {}
  union {
    ChartDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChartDefDefaultTypeInternal _ChartDef_default_instance_;
PROTOBUF_CONSTEXPR StraightLineDef::StraightLineDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_.vertical_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StraightLineDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StraightLineDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StraightLineDefDefaultTypeInternal() {}
  union {
    StraightLineDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StraightLineDefDefaultTypeInternal _StraightLineDef_default_instance_;
PROTOBUF_CONSTEXPR Band::Band(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_)*/nullptr
  , /*decltype(_impl_.to_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BandDefaultTypeInternal() {}
  union {
    Band _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandDefaultTypeInternal _Band_default_instance_;
PROTOBUF_CONSTEXPR Point::Point(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/int64_t{0}
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointDefaultTypeInternal() {}
  union {
    Point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointDefaultTypeInternal _Point_default_instance_;
PROTOBUF_CONSTEXPR Line::Line(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dash_style_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.line_width_)*/0u} {}
struct LineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LineDefaultTypeInternal() {}
  union {
    Line _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LineDefaultTypeInternal _Line_default_instance_;
PROTOBUF_CONSTEXPR LinesDef::LinesDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lines_)*/{}
  , /*decltype(_impl_.straight_lines_)*/{}
  , /*decltype(_impl_.y_plot_bands_)*/{}
  , /*decltype(_impl_.x_plot_bands_)*/{}
  , /*decltype(_impl_.chart_def_)*/nullptr
  , /*decltype(_impl_.overlay_)*/nullptr
  , /*decltype(_impl_.stacked_)*/false} {}
struct LinesDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinesDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinesDefDefaultTypeInternal() {}
  union {
    LinesDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinesDefDefaultTypeInternal _LinesDef_default_instance_;
PROTOBUF_CONSTEXPR HeatMapPoint::HeatMapPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/uint64_t{0u}
  , /*decltype(_impl_.y_)*/uint64_t{0u}
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeatMapPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeatMapPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeatMapPointDefaultTypeInternal() {}
  union {
    HeatMapPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeatMapPointDefaultTypeInternal _HeatMapPoint_default_instance_;
PROTOBUF_CONSTEXPR HeatMapDef::HeatMapDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.chart_def_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeatMapDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeatMapDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeatMapDefDefaultTypeInternal() {}
  union {
    HeatMapDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeatMapDefDefaultTypeInternal _HeatMapDef_default_instance_;
PROTOBUF_CONSTEXPR BarDef::BarDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.straight_lines_)*/{}
  , /*decltype(_impl_.chart_def_)*/nullptr
  , /*decltype(_impl_.data_)*/nullptr
  , /*decltype(_impl_.bar_width_)*/0u} {}
struct BarDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BarDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BarDefDefaultTypeInternal() {}
  union {
    BarDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BarDefDefaultTypeInternal _BarDef_default_instance_;
PROTOBUF_CONSTEXPR HistogramDef::HistogramDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.straight_lines_)*/{}
  , /*decltype(_impl_.chart_def_)*/nullptr
  , /*decltype(_impl_.data_)*/nullptr
  , /*decltype(_impl_.bins_count_)*/0u} {}
struct HistogramDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HistogramDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HistogramDefDefaultTypeInternal() {}
  union {
    HistogramDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HistogramDefDefaultTypeInternal _HistogramDef_default_instance_;
PROTOBUF_CONSTEXPR BoxPlotDataPoint::BoxPlotDataPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.low_)*/0
  , /*decltype(_impl_.q1_)*/0
  , /*decltype(_impl_.median_)*/0
  , /*decltype(_impl_.q3_)*/0
  , /*decltype(_impl_.high_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoxPlotDataPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoxPlotDataPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoxPlotDataPointDefaultTypeInternal() {}
  union {
    BoxPlotDataPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoxPlotDataPointDefaultTypeInternal _BoxPlotDataPoint_default_instance_;
PROTOBUF_CONSTEXPR BoxPlotOutlier::BoxPlotOutlier(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.category_index_)*/uint64_t{0u}
  , /*decltype(_impl_.value_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoxPlotOutlierDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoxPlotOutlierDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoxPlotOutlierDefaultTypeInternal() {}
  union {
    BoxPlotOutlier _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoxPlotOutlierDefaultTypeInternal _BoxPlotOutlier_default_instance_;
PROTOBUF_CONSTEXPR BoxPlotDataPointDef::BoxPlotDataPointDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.outliers_)*/{}
  , /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoxPlotDataPointDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoxPlotDataPointDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoxPlotDataPointDefDefaultTypeInternal() {}
  union {
    BoxPlotDataPointDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoxPlotDataPointDefDefaultTypeInternal _BoxPlotDataPointDef_default_instance_;
PROTOBUF_CONSTEXPR BoxPlotDef::BoxPlotDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.chart_def_)*/nullptr
  , /*decltype(_impl_.data_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoxPlotDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoxPlotDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoxPlotDefDefaultTypeInternal() {}
  union {
    BoxPlotDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoxPlotDefDefaultTypeInternal _BoxPlotDef_default_instance_;
PROTOBUF_CONSTEXPR XRangePoint::XRangePoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/int64_t{0}
  , /*decltype(_impl_.x2_)*/int64_t{0}
  , /*decltype(_impl_.y_)*/uint64_t{0u}
  , /*decltype(_impl_.is_long_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct XRangePointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XRangePointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~XRangePointDefaultTypeInternal() {}
  union {
    XRangePoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XRangePointDefaultTypeInternal _XRangePoint_default_instance_;
PROTOBUF_CONSTEXPR XRangeDef::XRangeDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.categories_)*/{}
  , /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.chart_def_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct XRangeDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XRangeDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~XRangeDefDefaultTypeInternal() {}
  union {
    XRangeDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XRangeDefDefaultTypeInternal _XRangeDef_default_instance_;
PROTOBUF_CONSTEXPR PieData::PieData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PieDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PieDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PieDataDefaultTypeInternal() {}
  union {
    PieData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PieDataDefaultTypeInternal _PieData_default_instance_;
PROTOBUF_CONSTEXPR PieDataDef::PieDataDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.inner_size_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PieDataDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PieDataDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PieDataDefDefaultTypeInternal() {}
  union {
    PieDataDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PieDataDefDefaultTypeInternal _PieDataDef_default_instance_;
PROTOBUF_CONSTEXPR PieDef::PieDef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.chart_def_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PieDefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PieDefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PieDefDefaultTypeInternal() {}
  union {
    PieDef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PieDefDefaultTypeInternal _PieDef_default_instance_;
PROTOBUF_CONSTEXPR Chart::Chart(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.chart_type_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ChartDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChartDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChartDefaultTypeInternal() {}
  union {
    Chart _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChartDefaultTypeInternal _Chart_default_instance_;
}  // namespace epoch_proto
static ::_pb::Metadata file_level_metadata_chart_5fdef_2eproto[21];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_chart_5fdef_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_chart_5fdef_2eproto = nullptr;

const uint32_t TableStruct_chart_5fdef_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::epoch_proto::AxisDef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::AxisDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::AxisDef, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::AxisDef, _impl_.label_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::AxisDef, _impl_.categories_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _impl_.category_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _impl_.y_axis_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::ChartDef, _impl_.x_axis_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::StraightLineDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::StraightLineDef, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::StraightLineDef, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::StraightLineDef, _impl_.vertical_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Band, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Band, _impl_.from_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Band, _impl_.to_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Point, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Point, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Line, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Line, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Line, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Line, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Line, _impl_.dash_style_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Line, _impl_.line_width_),
  ~0u,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_.chart_def_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_.lines_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_.straight_lines_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_.y_plot_bands_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_.x_plot_bands_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_.overlay_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::LinesDef, _impl_.stacked_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HeatMapPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HeatMapPoint, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HeatMapPoint, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HeatMapPoint, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HeatMapDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HeatMapDef, _impl_.chart_def_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HeatMapDef, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BarDef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BarDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BarDef, _impl_.chart_def_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BarDef, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BarDef, _impl_.straight_lines_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BarDef, _impl_.bar_width_),
  ~0u,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HistogramDef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HistogramDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HistogramDef, _impl_.chart_def_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HistogramDef, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HistogramDef, _impl_.straight_lines_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::HistogramDef, _impl_.bins_count_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPoint, _impl_.low_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPoint, _impl_.q1_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPoint, _impl_.median_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPoint, _impl_.q3_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPoint, _impl_.high_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotOutlier, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotOutlier, _impl_.category_index_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotOutlier, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPointDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPointDef, _impl_.outliers_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDataPointDef, _impl_.points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDef, _impl_.chart_def_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::BoxPlotDef, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangePoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangePoint, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangePoint, _impl_.x2_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangePoint, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangePoint, _impl_.is_long_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangeDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangeDef, _impl_.chart_def_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangeDef, _impl_.categories_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::XRangeDef, _impl_.points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieData, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieData, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDataDef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDataDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDataDef, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDataDef, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDataDef, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDataDef, _impl_.inner_size_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDef, _impl_.chart_def_),
  PROTOBUF_FIELD_OFFSET(::epoch_proto::PieDef, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Chart, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Chart, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::epoch_proto::Chart, _impl_.chart_type_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::epoch_proto::AxisDef)},
  { 12, 24, -1, sizeof(::epoch_proto::ChartDef)},
  { 30, -1, -1, sizeof(::epoch_proto::StraightLineDef)},
  { 39, -1, -1, sizeof(::epoch_proto::Band)},
  { 47, -1, -1, sizeof(::epoch_proto::Point)},
  { 55, 65, -1, sizeof(::epoch_proto::Line)},
  { 69, 82, -1, sizeof(::epoch_proto::LinesDef)},
  { 89, -1, -1, sizeof(::epoch_proto::HeatMapPoint)},
  { 98, -1, -1, sizeof(::epoch_proto::HeatMapDef)},
  { 106, 116, -1, sizeof(::epoch_proto::BarDef)},
  { 120, 130, -1, sizeof(::epoch_proto::HistogramDef)},
  { 134, -1, -1, sizeof(::epoch_proto::BoxPlotDataPoint)},
  { 145, -1, -1, sizeof(::epoch_proto::BoxPlotOutlier)},
  { 153, -1, -1, sizeof(::epoch_proto::BoxPlotDataPointDef)},
  { 161, -1, -1, sizeof(::epoch_proto::BoxPlotDef)},
  { 169, -1, -1, sizeof(::epoch_proto::XRangePoint)},
  { 179, -1, -1, sizeof(::epoch_proto::XRangeDef)},
  { 188, -1, -1, sizeof(::epoch_proto::PieData)},
  { 196, 206, -1, sizeof(::epoch_proto::PieDataDef)},
  { 210, -1, -1, sizeof(::epoch_proto::PieDef)},
  { 218, -1, -1, sizeof(::epoch_proto::Chart)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::epoch_proto::_AxisDef_default_instance_._instance,
  &::epoch_proto::_ChartDef_default_instance_._instance,
  &::epoch_proto::_StraightLineDef_default_instance_._instance,
  &::epoch_proto::_Band_default_instance_._instance,
  &::epoch_proto::_Point_default_instance_._instance,
  &::epoch_proto::_Line_default_instance_._instance,
  &::epoch_proto::_LinesDef_default_instance_._instance,
  &::epoch_proto::_HeatMapPoint_default_instance_._instance,
  &::epoch_proto::_HeatMapDef_default_instance_._instance,
  &::epoch_proto::_BarDef_default_instance_._instance,
  &::epoch_proto::_HistogramDef_default_instance_._instance,
  &::epoch_proto::_BoxPlotDataPoint_default_instance_._instance,
  &::epoch_proto::_BoxPlotOutlier_default_instance_._instance,
  &::epoch_proto::_BoxPlotDataPointDef_default_instance_._instance,
  &::epoch_proto::_BoxPlotDef_default_instance_._instance,
  &::epoch_proto::_XRangePoint_default_instance_._instance,
  &::epoch_proto::_XRangeDef_default_instance_._instance,
  &::epoch_proto::_PieData_default_instance_._instance,
  &::epoch_proto::_PieDataDef_default_instance_._instance,
  &::epoch_proto::_PieDef_default_instance_._instance,
  &::epoch_proto::_Chart_default_instance_._instance,
};

const char descriptor_table_protodef_chart_5fdef_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017chart_def.proto\022\013epoch_proto\032\014common.p"
  "roto\"n\n\007AxisDef\022(\n\004type\030\001 \001(\0162\025.epoch_pr"
  "oto.AxisTypeH\000\210\001\001\022\022\n\005label\030\002 \001(\tH\001\210\001\001\022\022\n"
  "\ncategories\030\003 \003(\tB\007\n\005_typeB\010\n\006_label\"\331\001\n"
  "\010ChartDef\022\n\n\002id\030\001 \001(\t\022\r\n\005title\030\002 \001(\t\0224\n\004"
  "type\030\003 \001(\0162&.epoch_proto.EpochFolioDashb"
  "oardWidget\022\020\n\010category\030\004 \001(\t\022)\n\006y_axis\030\005"
  " \001(\0132\024.epoch_proto.AxisDefH\000\210\001\001\022)\n\006x_axi"
  "s\030\006 \001(\0132\024.epoch_proto.AxisDefH\001\210\001\001B\t\n\007_y"
  "_axisB\t\n\007_x_axis\"A\n\017StraightLineDef\022\r\n\005t"
  "itle\030\001 \001(\t\022\r\n\005value\030\002 \001(\001\022\020\n\010vertical\030\003 "
  "\001(\010\"J\n\004Band\022!\n\004from\030\001 \001(\0132\023.epoch_proto."
  "Scalar\022\037\n\002to\030\002 \001(\0132\023.epoch_proto.Scalar\""
  "\035\n\005Point\022\t\n\001x\030\001 \001(\003\022\t\n\001y\030\002 \001(\001\"\206\001\n\004Line\022"
  " \n\004data\030\001 \003(\0132\022.epoch_proto.Point\022\014\n\004nam"
  "e\030\002 \001(\t\022\027\n\ndash_style\030\003 \001(\tH\000\210\001\001\022\027\n\nline"
  "_width\030\004 \001(\rH\001\210\001\001B\r\n\013_dash_styleB\r\n\013_lin"
  "e_width\"\244\002\n\010LinesDef\022(\n\tchart_def\030\001 \001(\0132"
  "\025.epoch_proto.ChartDef\022 \n\005lines\030\002 \003(\0132\021."
  "epoch_proto.Line\0224\n\016straight_lines\030\003 \003(\013"
  "2\034.epoch_proto.StraightLineDef\022\'\n\014y_plot"
  "_bands\030\004 \003(\0132\021.epoch_proto.Band\022\'\n\014x_plo"
  "t_bands\030\005 \003(\0132\021.epoch_proto.Band\022\'\n\007over"
  "lay\030\006 \001(\0132\021.epoch_proto.LineH\000\210\001\001\022\017\n\007sta"
  "cked\030\007 \001(\010B\n\n\010_overlay\"3\n\014HeatMapPoint\022\t"
  "\n\001x\030\001 \001(\004\022\t\n\001y\030\002 \001(\004\022\r\n\005value\030\003 \001(\001\"a\n\nH"
  "eatMapDef\022(\n\tchart_def\030\001 \001(\0132\025.epoch_pro"
  "to.ChartDef\022)\n\006points\030\002 \003(\0132\031.epoch_prot"
  "o.HeatMapPoint\"\260\001\n\006BarDef\022(\n\tchart_def\030\001"
  " \001(\0132\025.epoch_proto.ChartDef\022 \n\004data\030\002 \001("
  "\0132\022.epoch_proto.Array\0224\n\016straight_lines\030"
  "\003 \003(\0132\034.epoch_proto.StraightLineDef\022\026\n\tb"
  "ar_width\030\004 \001(\rH\000\210\001\001B\014\n\n_bar_width\"\270\001\n\014Hi"
  "stogramDef\022(\n\tchart_def\030\001 \001(\0132\025.epoch_pr"
  "oto.ChartDef\022 \n\004data\030\002 \001(\0132\022.epoch_proto"
  ".Array\0224\n\016straight_lines\030\003 \003(\0132\034.epoch_p"
  "roto.StraightLineDef\022\027\n\nbins_count\030\004 \001(\r"
  "H\000\210\001\001B\r\n\013_bins_count\"U\n\020BoxPlotDataPoint"
  "\022\013\n\003low\030\001 \001(\001\022\n\n\002q1\030\002 \001(\001\022\016\n\006median\030\003 \001("
  "\001\022\n\n\002q3\030\004 \001(\001\022\014\n\004high\030\005 \001(\001\"7\n\016BoxPlotOu"
  "tlier\022\026\n\016category_index\030\001 \001(\004\022\r\n\005value\030\002"
  " \001(\001\"s\n\023BoxPlotDataPointDef\022-\n\010outliers\030"
  "\001 \003(\0132\033.epoch_proto.BoxPlotOutlier\022-\n\006po"
  "ints\030\002 \003(\0132\035.epoch_proto.BoxPlotDataPoin"
  "t\"f\n\nBoxPlotDef\022(\n\tchart_def\030\001 \001(\0132\025.epo"
  "ch_proto.ChartDef\022.\n\004data\030\002 \001(\0132 .epoch_"
  "proto.BoxPlotDataPointDef\"@\n\013XRangePoint"
  "\022\t\n\001x\030\001 \001(\003\022\n\n\002x2\030\002 \001(\003\022\t\n\001y\030\003 \001(\004\022\017\n\007is"
  "_long\030\004 \001(\010\"s\n\tXRangeDef\022(\n\tchart_def\030\001 "
  "\001(\0132\025.epoch_proto.ChartDef\022\022\n\ncategories"
  "\030\002 \003(\t\022(\n\006points\030\003 \003(\0132\030.epoch_proto.XRa"
  "ngePoint\"\"\n\007PieData\022\014\n\004name\030\001 \001(\t\022\t\n\001y\030\002"
  " \001(\001\"v\n\nPieDataDef\022\014\n\004name\030\001 \001(\t\022$\n\006poin"
  "ts\030\002 \003(\0132\024.epoch_proto.PieData\022\014\n\004size\030\003"
  " \001(\t\022\027\n\ninner_size\030\004 \001(\tH\000\210\001\001B\r\n\013_inner_"
  "size\"Y\n\006PieDef\022(\n\tchart_def\030\001 \001(\0132\025.epoc"
  "h_proto.ChartDef\022%\n\004data\030\002 \003(\0132\027.epoch_p"
  "roto.PieDataDef\"\326\002\n\005Chart\022*\n\tlines_def\030\001"
  " \001(\0132\025.epoch_proto.LinesDefH\000\022/\n\014heat_ma"
  "p_def\030\002 \001(\0132\027.epoch_proto.HeatMapDefH\000\022&"
  "\n\007bar_def\030\003 \001(\0132\023.epoch_proto.BarDefH\000\0222"
  "\n\rhistogram_def\030\004 \001(\0132\031.epoch_proto.Hist"
  "ogramDefH\000\022/\n\014box_plot_def\030\005 \001(\0132\027.epoch"
  "_proto.BoxPlotDefH\000\022-\n\013x_range_def\030\006 \001(\013"
  "2\026.epoch_proto.XRangeDefH\000\022&\n\007pie_def\030\007 "
  "\001(\0132\023.epoch_proto.PieDefH\000B\014\n\nchart_type"
  "Bq\n\031com.epochlab.epoch_protosB\rChartDefP"
  "rotoZ#github.com/epochlab/epoch_protos/g"
  "o\252\002\037EpochLab.EpochProtos.EpochProtob\006pro"
  "to3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_chart_5fdef_2eproto_deps[1] = {
  &::descriptor_table_common_2eproto,
};
static ::_pbi::once_flag descriptor_table_chart_5fdef_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_chart_5fdef_2eproto = {
    false, false, 2763, descriptor_table_protodef_chart_5fdef_2eproto,
    "chart_def.proto",
    &descriptor_table_chart_5fdef_2eproto_once, descriptor_table_chart_5fdef_2eproto_deps, 1, 21,
    schemas, file_default_instances, TableStruct_chart_5fdef_2eproto::offsets,
    file_level_metadata_chart_5fdef_2eproto, file_level_enum_descriptors_chart_5fdef_2eproto,
    file_level_service_descriptors_chart_5fdef_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_chart_5fdef_2eproto_getter() {
  return &descriptor_table_chart_5fdef_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_chart_5fdef_2eproto(&descriptor_table_chart_5fdef_2eproto);
namespace epoch_proto {

// ===================================================================

class AxisDef::_Internal {
 public:
  using HasBits = decltype(std::declval<AxisDef>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AxisDef::AxisDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.AxisDef)
}
AxisDef::AxisDef(const AxisDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AxisDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.categories_){from._impl_.categories_}
    , decltype(_impl_.label_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    _this->_impl_.label_.Set(from._internal_label(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:epoch_proto.AxisDef)
}

inline void AxisDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.categories_){arena}
    , decltype(_impl_.label_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AxisDef::~AxisDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.AxisDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AxisDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.categories_.~RepeatedPtrField();
  _impl_.label_.Destroy();
}

void AxisDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AxisDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.AxisDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.categories_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.label_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AxisDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .epoch_proto.AxisType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::epoch_proto::AxisType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional string label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.AxisDef.label"));
        } else
          goto handle_unusual;
        continue;
      // repeated string categories = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_categories();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.AxisDef.categories"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AxisDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.AxisDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .epoch_proto.AxisType type = 1;
  if (_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string label = 2;
  if (_internal_has_label()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.AxisDef.label");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_label(), target);
  }

  // repeated string categories = 3;
  for (int i = 0, n = this->_internal_categories_size(); i < n; i++) {
    const auto& s = this->_internal_categories(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.AxisDef.categories");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.AxisDef)
  return target;
}

size_t AxisDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.AxisDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string categories = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.categories_.size());
  for (int i = 0, n = _impl_.categories_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.categories_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string label = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional .epoch_proto.AxisType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AxisDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AxisDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AxisDef::GetClassData() const { return &_class_data_; }


void AxisDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AxisDef*>(&to_msg);
  auto& from = static_cast<const AxisDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.AxisDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.categories_.MergeFrom(from._impl_.categories_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AxisDef::CopyFrom(const AxisDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.AxisDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AxisDef::IsInitialized() const {
  return true;
}

void AxisDef::InternalSwap(AxisDef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.categories_.InternalSwap(&other->_impl_.categories_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.label_, lhs_arena,
      &other->_impl_.label_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AxisDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[0]);
}

// ===================================================================

class ChartDef::_Internal {
 public:
  using HasBits = decltype(std::declval<ChartDef>()._impl_._has_bits_);
  static const ::epoch_proto::AxisDef& y_axis(const ChartDef* msg);
  static void set_has_y_axis(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::epoch_proto::AxisDef& x_axis(const ChartDef* msg);
  static void set_has_x_axis(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::epoch_proto::AxisDef&
ChartDef::_Internal::y_axis(const ChartDef* msg) {
  return *msg->_impl_.y_axis_;
}
const ::epoch_proto::AxisDef&
ChartDef::_Internal::x_axis(const ChartDef* msg) {
  return *msg->_impl_.x_axis_;
}
ChartDef::ChartDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.ChartDef)
}
ChartDef::ChartDef(const ChartDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChartDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.category_){}
    , decltype(_impl_.y_axis_){nullptr}
    , decltype(_impl_.x_axis_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_category().empty()) {
    _this->_impl_.category_.Set(from._internal_category(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_y_axis()) {
    _this->_impl_.y_axis_ = new ::epoch_proto::AxisDef(*from._impl_.y_axis_);
  }
  if (from._internal_has_x_axis()) {
    _this->_impl_.x_axis_ = new ::epoch_proto::AxisDef(*from._impl_.x_axis_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:epoch_proto.ChartDef)
}

inline void ChartDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.category_){}
    , decltype(_impl_.y_axis_){nullptr}
    , decltype(_impl_.x_axis_){nullptr}
    , decltype(_impl_.type_){0}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChartDef::~ChartDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.ChartDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChartDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.id_.Destroy();
  _impl_.title_.Destroy();
  _impl_.category_.Destroy();
  if (this != internal_default_instance()) delete _impl_.y_axis_;
  if (this != internal_default_instance()) delete _impl_.x_axis_;
}

void ChartDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChartDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.ChartDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  _impl_.title_.ClearToEmpty();
  _impl_.category_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.y_axis_ != nullptr);
      _impl_.y_axis_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.x_axis_ != nullptr);
      _impl_.x_axis_->Clear();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChartDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.ChartDef.id"));
        } else
          goto handle_unusual;
        continue;
      // string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.ChartDef.title"));
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.EpochFolioDashboardWidget type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::epoch_proto::EpochFolioDashboardWidget>(val));
        } else
          goto handle_unusual;
        continue;
      // string category = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_category();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.ChartDef.category"));
        } else
          goto handle_unusual;
        continue;
      // optional .epoch_proto.AxisDef y_axis = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_y_axis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .epoch_proto.AxisDef x_axis = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_x_axis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChartDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.ChartDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.ChartDef.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string title = 2;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.ChartDef.title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // .epoch_proto.EpochFolioDashboardWidget type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // string category = 4;
  if (!this->_internal_category().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_category().data(), static_cast<int>(this->_internal_category().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.ChartDef.category");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_category(), target);
  }

  // optional .epoch_proto.AxisDef y_axis = 5;
  if (_internal_has_y_axis()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::y_axis(this),
        _Internal::y_axis(this).GetCachedSize(), target, stream);
  }

  // optional .epoch_proto.AxisDef x_axis = 6;
  if (_internal_has_x_axis()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::x_axis(this),
        _Internal::x_axis(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.ChartDef)
  return target;
}

size_t ChartDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.ChartDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string title = 2;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string category = 4;
  if (!this->_internal_category().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_category());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .epoch_proto.AxisDef y_axis = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.y_axis_);
    }

    // optional .epoch_proto.AxisDef x_axis = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.x_axis_);
    }

  }
  // .epoch_proto.EpochFolioDashboardWidget type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChartDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChartDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChartDef::GetClassData() const { return &_class_data_; }


void ChartDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChartDef*>(&to_msg);
  auto& from = static_cast<const ChartDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.ChartDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_category().empty()) {
    _this->_internal_set_category(from._internal_category());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_y_axis()->::epoch_proto::AxisDef::MergeFrom(
          from._internal_y_axis());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_x_axis()->::epoch_proto::AxisDef::MergeFrom(
          from._internal_x_axis());
    }
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChartDef::CopyFrom(const ChartDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.ChartDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChartDef::IsInitialized() const {
  return true;
}

void ChartDef::InternalSwap(ChartDef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.category_, lhs_arena,
      &other->_impl_.category_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChartDef, _impl_.type_)
      + sizeof(ChartDef::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(ChartDef, _impl_.y_axis_)>(
          reinterpret_cast<char*>(&_impl_.y_axis_),
          reinterpret_cast<char*>(&other->_impl_.y_axis_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChartDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[1]);
}

// ===================================================================

class StraightLineDef::_Internal {
 public:
};

StraightLineDef::StraightLineDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.StraightLineDef)
}
StraightLineDef::StraightLineDef(const StraightLineDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StraightLineDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.title_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.vertical_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.value_, &from._impl_.value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vertical_) -
    reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.vertical_));
  // @@protoc_insertion_point(copy_constructor:epoch_proto.StraightLineDef)
}

inline void StraightLineDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.title_){}
    , decltype(_impl_.value_){0}
    , decltype(_impl_.vertical_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StraightLineDef::~StraightLineDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.StraightLineDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StraightLineDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.Destroy();
}

void StraightLineDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StraightLineDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.StraightLineDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.title_.ClearToEmpty();
  ::memset(&_impl_.value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.vertical_) -
      reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.vertical_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StraightLineDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.StraightLineDef.title"));
        } else
          goto handle_unusual;
        continue;
      // double value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool vertical = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.vertical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StraightLineDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.StraightLineDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string title = 1;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.StraightLineDef.title");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // double value = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
  }

  // bool vertical = 3;
  if (this->_internal_vertical() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_vertical(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.StraightLineDef)
  return target;
}

size_t StraightLineDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.StraightLineDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string title = 1;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // double value = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 8;
  }

  // bool vertical = 3;
  if (this->_internal_vertical() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StraightLineDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StraightLineDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StraightLineDef::GetClassData() const { return &_class_data_; }


void StraightLineDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StraightLineDef*>(&to_msg);
  auto& from = static_cast<const StraightLineDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.StraightLineDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = from._internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_vertical() != 0) {
    _this->_internal_set_vertical(from._internal_vertical());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StraightLineDef::CopyFrom(const StraightLineDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.StraightLineDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StraightLineDef::IsInitialized() const {
  return true;
}

void StraightLineDef::InternalSwap(StraightLineDef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StraightLineDef, _impl_.vertical_)
      + sizeof(StraightLineDef::_impl_.vertical_)
      - PROTOBUF_FIELD_OFFSET(StraightLineDef, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StraightLineDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[2]);
}

// ===================================================================

class Band::_Internal {
 public:
  static const ::epoch_proto::Scalar& from(const Band* msg);
  static const ::epoch_proto::Scalar& to(const Band* msg);
};

const ::epoch_proto::Scalar&
Band::_Internal::from(const Band* msg) {
  return *msg->_impl_.from_;
}
const ::epoch_proto::Scalar&
Band::_Internal::to(const Band* msg) {
  return *msg->_impl_.to_;
}
void Band::clear_from() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
}
void Band::clear_to() {
  if (GetArenaForAllocation() == nullptr && _impl_.to_ != nullptr) {
    delete _impl_.to_;
  }
  _impl_.to_ = nullptr;
}
Band::Band(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.Band)
}
Band::Band(const Band& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Band* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){nullptr}
    , decltype(_impl_.to_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_from()) {
    _this->_impl_.from_ = new ::epoch_proto::Scalar(*from._impl_.from_);
  }
  if (from._internal_has_to()) {
    _this->_impl_.to_ = new ::epoch_proto::Scalar(*from._impl_.to_);
  }
  // @@protoc_insertion_point(copy_constructor:epoch_proto.Band)
}

inline void Band::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){nullptr}
    , decltype(_impl_.to_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Band::~Band() {
  // @@protoc_insertion_point(destructor:epoch_proto.Band)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Band::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.from_;
  if (this != internal_default_instance()) delete _impl_.to_;
}

void Band::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Band::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.Band)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.to_ != nullptr) {
    delete _impl_.to_;
  }
  _impl_.to_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Band::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.Scalar from = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_from(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.Scalar to = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_to(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Band::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.Band)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.Scalar from = 1;
  if (this->_internal_has_from()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::from(this),
        _Internal::from(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.Scalar to = 2;
  if (this->_internal_has_to()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::to(this),
        _Internal::to(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.Band)
  return target;
}

size_t Band::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.Band)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .epoch_proto.Scalar from = 1;
  if (this->_internal_has_from()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.from_);
  }

  // .epoch_proto.Scalar to = 2;
  if (this->_internal_has_to()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.to_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Band::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Band::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Band::GetClassData() const { return &_class_data_; }


void Band::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Band*>(&to_msg);
  auto& from = static_cast<const Band&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.Band)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_from()) {
    _this->_internal_mutable_from()->::epoch_proto::Scalar::MergeFrom(
        from._internal_from());
  }
  if (from._internal_has_to()) {
    _this->_internal_mutable_to()->::epoch_proto::Scalar::MergeFrom(
        from._internal_to());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Band::CopyFrom(const Band& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.Band)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Band::IsInitialized() const {
  return true;
}

void Band::InternalSwap(Band* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Band, _impl_.to_)
      + sizeof(Band::_impl_.to_)
      - PROTOBUF_FIELD_OFFSET(Band, _impl_.from_)>(
          reinterpret_cast<char*>(&_impl_.from_),
          reinterpret_cast<char*>(&other->_impl_.from_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Band::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[3]);
}

// ===================================================================

class Point::_Internal {
 public:
};

Point::Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.Point)
}
Point::Point(const Point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Point* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:epoch_proto.Point)
}

inline void Point::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){int64_t{0}}
    , decltype(_impl_.y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:epoch_proto.Point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Point::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.Point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.Point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_x(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.Point)
  return target;
}

size_t Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.Point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_x());
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Point::GetClassData() const { return &_class_data_; }


void Point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Point*>(&to_msg);
  auto& from = static_cast<const Point&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.Point)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  return true;
}

void Point::InternalSwap(Point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Point, _impl_.y_)
      + sizeof(Point::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Point, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Point::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[4]);
}

// ===================================================================

class Line::_Internal {
 public:
  using HasBits = decltype(std::declval<Line>()._impl_._has_bits_);
  static void set_has_dash_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_line_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Line::Line(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.Line)
}
Line::Line(const Line& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Line* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){from._impl_.data_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.dash_style_){}
    , decltype(_impl_.line_width_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dash_style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dash_style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dash_style()) {
    _this->_impl_.dash_style_.Set(from._internal_dash_style(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.line_width_ = from._impl_.line_width_;
  // @@protoc_insertion_point(copy_constructor:epoch_proto.Line)
}

inline void Line::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.dash_style_){}
    , decltype(_impl_.line_width_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dash_style_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dash_style_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Line::~Line() {
  // @@protoc_insertion_point(destructor:epoch_proto.Line)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Line::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.dash_style_.Destroy();
}

void Line::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Line::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.Line)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.dash_style_.ClearNonDefaultToEmpty();
  }
  _impl_.line_width_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Line::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .epoch_proto.Point data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.Line.name"));
        } else
          goto handle_unusual;
        continue;
      // optional string dash_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dash_style();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.Line.dash_style"));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 line_width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_line_width(&has_bits);
          _impl_.line_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Line::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.Line)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .epoch_proto.Point data = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.Line.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string dash_style = 3;
  if (_internal_has_dash_style()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dash_style().data(), static_cast<int>(this->_internal_dash_style().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.Line.dash_style");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_dash_style(), target);
  }

  // optional uint32 line_width = 4;
  if (_internal_has_line_width()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_line_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.Line)
  return target;
}

size_t Line::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.Line)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.Point data = 1;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->_impl_.data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string dash_style = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dash_style());
    }

    // optional uint32 line_width = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_line_width());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Line::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Line::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Line::GetClassData() const { return &_class_data_; }


void Line::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Line*>(&to_msg);
  auto& from = static_cast<const Line&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.Line)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_dash_style(from._internal_dash_style());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.line_width_ = from._impl_.line_width_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Line::CopyFrom(const Line& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.Line)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Line::IsInitialized() const {
  return true;
}

void Line::InternalSwap(Line* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dash_style_, lhs_arena,
      &other->_impl_.dash_style_, rhs_arena
  );
  swap(_impl_.line_width_, other->_impl_.line_width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Line::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[5]);
}

// ===================================================================

class LinesDef::_Internal {
 public:
  using HasBits = decltype(std::declval<LinesDef>()._impl_._has_bits_);
  static const ::epoch_proto::ChartDef& chart_def(const LinesDef* msg);
  static const ::epoch_proto::Line& overlay(const LinesDef* msg);
  static void set_has_overlay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::epoch_proto::ChartDef&
LinesDef::_Internal::chart_def(const LinesDef* msg) {
  return *msg->_impl_.chart_def_;
}
const ::epoch_proto::Line&
LinesDef::_Internal::overlay(const LinesDef* msg) {
  return *msg->_impl_.overlay_;
}
LinesDef::LinesDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.LinesDef)
}
LinesDef::LinesDef(const LinesDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinesDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lines_){from._impl_.lines_}
    , decltype(_impl_.straight_lines_){from._impl_.straight_lines_}
    , decltype(_impl_.y_plot_bands_){from._impl_.y_plot_bands_}
    , decltype(_impl_.x_plot_bands_){from._impl_.x_plot_bands_}
    , decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.overlay_){nullptr}
    , decltype(_impl_.stacked_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chart_def()) {
    _this->_impl_.chart_def_ = new ::epoch_proto::ChartDef(*from._impl_.chart_def_);
  }
  if (from._internal_has_overlay()) {
    _this->_impl_.overlay_ = new ::epoch_proto::Line(*from._impl_.overlay_);
  }
  _this->_impl_.stacked_ = from._impl_.stacked_;
  // @@protoc_insertion_point(copy_constructor:epoch_proto.LinesDef)
}

inline void LinesDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lines_){arena}
    , decltype(_impl_.straight_lines_){arena}
    , decltype(_impl_.y_plot_bands_){arena}
    , decltype(_impl_.x_plot_bands_){arena}
    , decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.overlay_){nullptr}
    , decltype(_impl_.stacked_){false}
  };
}

LinesDef::~LinesDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.LinesDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinesDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lines_.~RepeatedPtrField();
  _impl_.straight_lines_.~RepeatedPtrField();
  _impl_.y_plot_bands_.~RepeatedPtrField();
  _impl_.x_plot_bands_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.chart_def_;
  if (this != internal_default_instance()) delete _impl_.overlay_;
}

void LinesDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinesDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.LinesDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lines_.Clear();
  _impl_.straight_lines_.Clear();
  _impl_.y_plot_bands_.Clear();
  _impl_.x_plot_bands_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.overlay_ != nullptr);
    _impl_.overlay_->Clear();
  }
  _impl_.stacked_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinesDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.ChartDef chart_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chart_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.Line lines = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.StraightLineDef straight_lines = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_straight_lines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.Band y_plot_bands = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_y_plot_bands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.Band x_plot_bands = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_x_plot_bands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .epoch_proto.Line overlay = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_overlay(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool stacked = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.stacked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinesDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.LinesDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chart_def(this),
        _Internal::chart_def(this).GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.Line lines = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lines_size()); i < n; i++) {
    const auto& repfield = this->_internal_lines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_straight_lines_size()); i < n; i++) {
    const auto& repfield = this->_internal_straight_lines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.Band y_plot_bands = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_y_plot_bands_size()); i < n; i++) {
    const auto& repfield = this->_internal_y_plot_bands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.Band x_plot_bands = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_x_plot_bands_size()); i < n; i++) {
    const auto& repfield = this->_internal_x_plot_bands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .epoch_proto.Line overlay = 6;
  if (_internal_has_overlay()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::overlay(this),
        _Internal::overlay(this).GetCachedSize(), target, stream);
  }

  // bool stacked = 7;
  if (this->_internal_stacked() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_stacked(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.LinesDef)
  return target;
}

size_t LinesDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.LinesDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.Line lines = 2;
  total_size += 1UL * this->_internal_lines_size();
  for (const auto& msg : this->_impl_.lines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  total_size += 1UL * this->_internal_straight_lines_size();
  for (const auto& msg : this->_impl_.straight_lines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .epoch_proto.Band y_plot_bands = 4;
  total_size += 1UL * this->_internal_y_plot_bands_size();
  for (const auto& msg : this->_impl_.y_plot_bands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .epoch_proto.Band x_plot_bands = 5;
  total_size += 1UL * this->_internal_x_plot_bands_size();
  for (const auto& msg : this->_impl_.x_plot_bands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chart_def_);
  }

  // optional .epoch_proto.Line overlay = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.overlay_);
  }

  // bool stacked = 7;
  if (this->_internal_stacked() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinesDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinesDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinesDef::GetClassData() const { return &_class_data_; }


void LinesDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinesDef*>(&to_msg);
  auto& from = static_cast<const LinesDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.LinesDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.lines_.MergeFrom(from._impl_.lines_);
  _this->_impl_.straight_lines_.MergeFrom(from._impl_.straight_lines_);
  _this->_impl_.y_plot_bands_.MergeFrom(from._impl_.y_plot_bands_);
  _this->_impl_.x_plot_bands_.MergeFrom(from._impl_.x_plot_bands_);
  if (from._internal_has_chart_def()) {
    _this->_internal_mutable_chart_def()->::epoch_proto::ChartDef::MergeFrom(
        from._internal_chart_def());
  }
  if (from._internal_has_overlay()) {
    _this->_internal_mutable_overlay()->::epoch_proto::Line::MergeFrom(
        from._internal_overlay());
  }
  if (from._internal_stacked() != 0) {
    _this->_internal_set_stacked(from._internal_stacked());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinesDef::CopyFrom(const LinesDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.LinesDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinesDef::IsInitialized() const {
  return true;
}

void LinesDef::InternalSwap(LinesDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.lines_.InternalSwap(&other->_impl_.lines_);
  _impl_.straight_lines_.InternalSwap(&other->_impl_.straight_lines_);
  _impl_.y_plot_bands_.InternalSwap(&other->_impl_.y_plot_bands_);
  _impl_.x_plot_bands_.InternalSwap(&other->_impl_.x_plot_bands_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LinesDef, _impl_.stacked_)
      + sizeof(LinesDef::_impl_.stacked_)
      - PROTOBUF_FIELD_OFFSET(LinesDef, _impl_.chart_def_)>(
          reinterpret_cast<char*>(&_impl_.chart_def_),
          reinterpret_cast<char*>(&other->_impl_.chart_def_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LinesDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[6]);
}

// ===================================================================

class HeatMapPoint::_Internal {
 public:
};

HeatMapPoint::HeatMapPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.HeatMapPoint)
}
HeatMapPoint::HeatMapPoint(const HeatMapPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeatMapPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:epoch_proto.HeatMapPoint)
}

inline void HeatMapPoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){uint64_t{0u}}
    , decltype(_impl_.y_){uint64_t{0u}}
    , decltype(_impl_.value_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HeatMapPoint::~HeatMapPoint() {
  // @@protoc_insertion_point(destructor:epoch_proto.HeatMapPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeatMapPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HeatMapPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeatMapPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.HeatMapPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.value_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeatMapPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeatMapPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.HeatMapPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_x(), target);
  }

  // uint64 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_y(), target);
  }

  // double value = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.HeatMapPoint)
  return target;
}

size_t HeatMapPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.HeatMapPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_x());
  }

  // uint64 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_y());
  }

  // double value = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeatMapPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeatMapPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeatMapPoint::GetClassData() const { return &_class_data_; }


void HeatMapPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeatMapPoint*>(&to_msg);
  auto& from = static_cast<const HeatMapPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.HeatMapPoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = from._internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeatMapPoint::CopyFrom(const HeatMapPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.HeatMapPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeatMapPoint::IsInitialized() const {
  return true;
}

void HeatMapPoint::InternalSwap(HeatMapPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeatMapPoint, _impl_.value_)
      + sizeof(HeatMapPoint::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(HeatMapPoint, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HeatMapPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[7]);
}

// ===================================================================

class HeatMapDef::_Internal {
 public:
  static const ::epoch_proto::ChartDef& chart_def(const HeatMapDef* msg);
};

const ::epoch_proto::ChartDef&
HeatMapDef::_Internal::chart_def(const HeatMapDef* msg) {
  return *msg->_impl_.chart_def_;
}
HeatMapDef::HeatMapDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.HeatMapDef)
}
HeatMapDef::HeatMapDef(const HeatMapDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeatMapDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.chart_def_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chart_def()) {
    _this->_impl_.chart_def_ = new ::epoch_proto::ChartDef(*from._impl_.chart_def_);
  }
  // @@protoc_insertion_point(copy_constructor:epoch_proto.HeatMapDef)
}

inline void HeatMapDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena}
    , decltype(_impl_.chart_def_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HeatMapDef::~HeatMapDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.HeatMapDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeatMapDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.chart_def_;
}

void HeatMapDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeatMapDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.HeatMapDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeatMapDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.ChartDef chart_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chart_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.HeatMapPoint points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeatMapDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.HeatMapDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chart_def(this),
        _Internal::chart_def(this).GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.HeatMapPoint points = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.HeatMapDef)
  return target;
}

size_t HeatMapDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.HeatMapDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.HeatMapPoint points = 2;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chart_def_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeatMapDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeatMapDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeatMapDef::GetClassData() const { return &_class_data_; }


void HeatMapDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeatMapDef*>(&to_msg);
  auto& from = static_cast<const HeatMapDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.HeatMapDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  if (from._internal_has_chart_def()) {
    _this->_internal_mutable_chart_def()->::epoch_proto::ChartDef::MergeFrom(
        from._internal_chart_def());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeatMapDef::CopyFrom(const HeatMapDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.HeatMapDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeatMapDef::IsInitialized() const {
  return true;
}

void HeatMapDef::InternalSwap(HeatMapDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  swap(_impl_.chart_def_, other->_impl_.chart_def_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HeatMapDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[8]);
}

// ===================================================================

class BarDef::_Internal {
 public:
  using HasBits = decltype(std::declval<BarDef>()._impl_._has_bits_);
  static const ::epoch_proto::ChartDef& chart_def(const BarDef* msg);
  static const ::epoch_proto::Array& data(const BarDef* msg);
  static void set_has_bar_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::epoch_proto::ChartDef&
BarDef::_Internal::chart_def(const BarDef* msg) {
  return *msg->_impl_.chart_def_;
}
const ::epoch_proto::Array&
BarDef::_Internal::data(const BarDef* msg) {
  return *msg->_impl_.data_;
}
void BarDef::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
BarDef::BarDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.BarDef)
}
BarDef::BarDef(const BarDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BarDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.straight_lines_){from._impl_.straight_lines_}
    , decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.bar_width_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chart_def()) {
    _this->_impl_.chart_def_ = new ::epoch_proto::ChartDef(*from._impl_.chart_def_);
  }
  if (from._internal_has_data()) {
    _this->_impl_.data_ = new ::epoch_proto::Array(*from._impl_.data_);
  }
  _this->_impl_.bar_width_ = from._impl_.bar_width_;
  // @@protoc_insertion_point(copy_constructor:epoch_proto.BarDef)
}

inline void BarDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.straight_lines_){arena}
    , decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.bar_width_){0u}
  };
}

BarDef::~BarDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.BarDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BarDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.straight_lines_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.chart_def_;
  if (this != internal_default_instance()) delete _impl_.data_;
}

void BarDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BarDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.BarDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.straight_lines_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
  _impl_.bar_width_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BarDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.ChartDef chart_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chart_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.Array data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.StraightLineDef straight_lines = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_straight_lines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bar_width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bar_width(&has_bits);
          _impl_.bar_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BarDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.BarDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chart_def(this),
        _Internal::chart_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.Array data = 2;
  if (this->_internal_has_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_straight_lines_size()); i < n; i++) {
    const auto& repfield = this->_internal_straight_lines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 bar_width = 4;
  if (_internal_has_bar_width()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bar_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.BarDef)
  return target;
}

size_t BarDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.BarDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  total_size += 1UL * this->_internal_straight_lines_size();
  for (const auto& msg : this->_impl_.straight_lines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chart_def_);
  }

  // .epoch_proto.Array data = 2;
  if (this->_internal_has_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.data_);
  }

  // optional uint32 bar_width = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bar_width());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BarDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BarDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BarDef::GetClassData() const { return &_class_data_; }


void BarDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BarDef*>(&to_msg);
  auto& from = static_cast<const BarDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.BarDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.straight_lines_.MergeFrom(from._impl_.straight_lines_);
  if (from._internal_has_chart_def()) {
    _this->_internal_mutable_chart_def()->::epoch_proto::ChartDef::MergeFrom(
        from._internal_chart_def());
  }
  if (from._internal_has_data()) {
    _this->_internal_mutable_data()->::epoch_proto::Array::MergeFrom(
        from._internal_data());
  }
  if (from._internal_has_bar_width()) {
    _this->_internal_set_bar_width(from._internal_bar_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BarDef::CopyFrom(const BarDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.BarDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BarDef::IsInitialized() const {
  return true;
}

void BarDef::InternalSwap(BarDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.straight_lines_.InternalSwap(&other->_impl_.straight_lines_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BarDef, _impl_.bar_width_)
      + sizeof(BarDef::_impl_.bar_width_)
      - PROTOBUF_FIELD_OFFSET(BarDef, _impl_.chart_def_)>(
          reinterpret_cast<char*>(&_impl_.chart_def_),
          reinterpret_cast<char*>(&other->_impl_.chart_def_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BarDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[9]);
}

// ===================================================================

class HistogramDef::_Internal {
 public:
  using HasBits = decltype(std::declval<HistogramDef>()._impl_._has_bits_);
  static const ::epoch_proto::ChartDef& chart_def(const HistogramDef* msg);
  static const ::epoch_proto::Array& data(const HistogramDef* msg);
  static void set_has_bins_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::epoch_proto::ChartDef&
HistogramDef::_Internal::chart_def(const HistogramDef* msg) {
  return *msg->_impl_.chart_def_;
}
const ::epoch_proto::Array&
HistogramDef::_Internal::data(const HistogramDef* msg) {
  return *msg->_impl_.data_;
}
void HistogramDef::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
HistogramDef::HistogramDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.HistogramDef)
}
HistogramDef::HistogramDef(const HistogramDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HistogramDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.straight_lines_){from._impl_.straight_lines_}
    , decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.bins_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chart_def()) {
    _this->_impl_.chart_def_ = new ::epoch_proto::ChartDef(*from._impl_.chart_def_);
  }
  if (from._internal_has_data()) {
    _this->_impl_.data_ = new ::epoch_proto::Array(*from._impl_.data_);
  }
  _this->_impl_.bins_count_ = from._impl_.bins_count_;
  // @@protoc_insertion_point(copy_constructor:epoch_proto.HistogramDef)
}

inline void HistogramDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.straight_lines_){arena}
    , decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.bins_count_){0u}
  };
}

HistogramDef::~HistogramDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.HistogramDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HistogramDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.straight_lines_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.chart_def_;
  if (this != internal_default_instance()) delete _impl_.data_;
}

void HistogramDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HistogramDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.HistogramDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.straight_lines_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
  _impl_.bins_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HistogramDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.ChartDef chart_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chart_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.Array data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.StraightLineDef straight_lines = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_straight_lines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bins_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bins_count(&has_bits);
          _impl_.bins_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HistogramDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.HistogramDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chart_def(this),
        _Internal::chart_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.Array data = 2;
  if (this->_internal_has_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_straight_lines_size()); i < n; i++) {
    const auto& repfield = this->_internal_straight_lines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 bins_count = 4;
  if (_internal_has_bins_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bins_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.HistogramDef)
  return target;
}

size_t HistogramDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.HistogramDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.StraightLineDef straight_lines = 3;
  total_size += 1UL * this->_internal_straight_lines_size();
  for (const auto& msg : this->_impl_.straight_lines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chart_def_);
  }

  // .epoch_proto.Array data = 2;
  if (this->_internal_has_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.data_);
  }

  // optional uint32 bins_count = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bins_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HistogramDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HistogramDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HistogramDef::GetClassData() const { return &_class_data_; }


void HistogramDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HistogramDef*>(&to_msg);
  auto& from = static_cast<const HistogramDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.HistogramDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.straight_lines_.MergeFrom(from._impl_.straight_lines_);
  if (from._internal_has_chart_def()) {
    _this->_internal_mutable_chart_def()->::epoch_proto::ChartDef::MergeFrom(
        from._internal_chart_def());
  }
  if (from._internal_has_data()) {
    _this->_internal_mutable_data()->::epoch_proto::Array::MergeFrom(
        from._internal_data());
  }
  if (from._internal_has_bins_count()) {
    _this->_internal_set_bins_count(from._internal_bins_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HistogramDef::CopyFrom(const HistogramDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.HistogramDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HistogramDef::IsInitialized() const {
  return true;
}

void HistogramDef::InternalSwap(HistogramDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.straight_lines_.InternalSwap(&other->_impl_.straight_lines_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HistogramDef, _impl_.bins_count_)
      + sizeof(HistogramDef::_impl_.bins_count_)
      - PROTOBUF_FIELD_OFFSET(HistogramDef, _impl_.chart_def_)>(
          reinterpret_cast<char*>(&_impl_.chart_def_),
          reinterpret_cast<char*>(&other->_impl_.chart_def_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HistogramDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[10]);
}

// ===================================================================

class BoxPlotDataPoint::_Internal {
 public:
};

BoxPlotDataPoint::BoxPlotDataPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.BoxPlotDataPoint)
}
BoxPlotDataPoint::BoxPlotDataPoint(const BoxPlotDataPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoxPlotDataPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.low_){}
    , decltype(_impl_.q1_){}
    , decltype(_impl_.median_){}
    , decltype(_impl_.q3_){}
    , decltype(_impl_.high_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.low_, &from._impl_.low_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.high_) -
    reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  // @@protoc_insertion_point(copy_constructor:epoch_proto.BoxPlotDataPoint)
}

inline void BoxPlotDataPoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.low_){0}
    , decltype(_impl_.q1_){0}
    , decltype(_impl_.median_){0}
    , decltype(_impl_.q3_){0}
    , decltype(_impl_.high_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BoxPlotDataPoint::~BoxPlotDataPoint() {
  // @@protoc_insertion_point(destructor:epoch_proto.BoxPlotDataPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoxPlotDataPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BoxPlotDataPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoxPlotDataPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.BoxPlotDataPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.low_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.high_) -
      reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoxPlotDataPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double low = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.low_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double q1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.q1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double median = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.median_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double q3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.q3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double high = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.high_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoxPlotDataPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.BoxPlotDataPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double low = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_low = this->_internal_low();
  uint64_t raw_low;
  memcpy(&raw_low, &tmp_low, sizeof(tmp_low));
  if (raw_low != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_low(), target);
  }

  // double q1 = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_q1 = this->_internal_q1();
  uint64_t raw_q1;
  memcpy(&raw_q1, &tmp_q1, sizeof(tmp_q1));
  if (raw_q1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_q1(), target);
  }

  // double median = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_median = this->_internal_median();
  uint64_t raw_median;
  memcpy(&raw_median, &tmp_median, sizeof(tmp_median));
  if (raw_median != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_median(), target);
  }

  // double q3 = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_q3 = this->_internal_q3();
  uint64_t raw_q3;
  memcpy(&raw_q3, &tmp_q3, sizeof(tmp_q3));
  if (raw_q3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_q3(), target);
  }

  // double high = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_high = this->_internal_high();
  uint64_t raw_high;
  memcpy(&raw_high, &tmp_high, sizeof(tmp_high));
  if (raw_high != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_high(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.BoxPlotDataPoint)
  return target;
}

size_t BoxPlotDataPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.BoxPlotDataPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double low = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_low = this->_internal_low();
  uint64_t raw_low;
  memcpy(&raw_low, &tmp_low, sizeof(tmp_low));
  if (raw_low != 0) {
    total_size += 1 + 8;
  }

  // double q1 = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_q1 = this->_internal_q1();
  uint64_t raw_q1;
  memcpy(&raw_q1, &tmp_q1, sizeof(tmp_q1));
  if (raw_q1 != 0) {
    total_size += 1 + 8;
  }

  // double median = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_median = this->_internal_median();
  uint64_t raw_median;
  memcpy(&raw_median, &tmp_median, sizeof(tmp_median));
  if (raw_median != 0) {
    total_size += 1 + 8;
  }

  // double q3 = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_q3 = this->_internal_q3();
  uint64_t raw_q3;
  memcpy(&raw_q3, &tmp_q3, sizeof(tmp_q3));
  if (raw_q3 != 0) {
    total_size += 1 + 8;
  }

  // double high = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_high = this->_internal_high();
  uint64_t raw_high;
  memcpy(&raw_high, &tmp_high, sizeof(tmp_high));
  if (raw_high != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoxPlotDataPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoxPlotDataPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoxPlotDataPoint::GetClassData() const { return &_class_data_; }


void BoxPlotDataPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoxPlotDataPoint*>(&to_msg);
  auto& from = static_cast<const BoxPlotDataPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.BoxPlotDataPoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_low = from._internal_low();
  uint64_t raw_low;
  memcpy(&raw_low, &tmp_low, sizeof(tmp_low));
  if (raw_low != 0) {
    _this->_internal_set_low(from._internal_low());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_q1 = from._internal_q1();
  uint64_t raw_q1;
  memcpy(&raw_q1, &tmp_q1, sizeof(tmp_q1));
  if (raw_q1 != 0) {
    _this->_internal_set_q1(from._internal_q1());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_median = from._internal_median();
  uint64_t raw_median;
  memcpy(&raw_median, &tmp_median, sizeof(tmp_median));
  if (raw_median != 0) {
    _this->_internal_set_median(from._internal_median());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_q3 = from._internal_q3();
  uint64_t raw_q3;
  memcpy(&raw_q3, &tmp_q3, sizeof(tmp_q3));
  if (raw_q3 != 0) {
    _this->_internal_set_q3(from._internal_q3());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_high = from._internal_high();
  uint64_t raw_high;
  memcpy(&raw_high, &tmp_high, sizeof(tmp_high));
  if (raw_high != 0) {
    _this->_internal_set_high(from._internal_high());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoxPlotDataPoint::CopyFrom(const BoxPlotDataPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.BoxPlotDataPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoxPlotDataPoint::IsInitialized() const {
  return true;
}

void BoxPlotDataPoint::InternalSwap(BoxPlotDataPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BoxPlotDataPoint, _impl_.high_)
      + sizeof(BoxPlotDataPoint::_impl_.high_)
      - PROTOBUF_FIELD_OFFSET(BoxPlotDataPoint, _impl_.low_)>(
          reinterpret_cast<char*>(&_impl_.low_),
          reinterpret_cast<char*>(&other->_impl_.low_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BoxPlotDataPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[11]);
}

// ===================================================================

class BoxPlotOutlier::_Internal {
 public:
};

BoxPlotOutlier::BoxPlotOutlier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.BoxPlotOutlier)
}
BoxPlotOutlier::BoxPlotOutlier(const BoxPlotOutlier& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoxPlotOutlier* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.category_index_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.category_index_, &from._impl_.category_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.category_index_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:epoch_proto.BoxPlotOutlier)
}

inline void BoxPlotOutlier::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.category_index_){uint64_t{0u}}
    , decltype(_impl_.value_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BoxPlotOutlier::~BoxPlotOutlier() {
  // @@protoc_insertion_point(destructor:epoch_proto.BoxPlotOutlier)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoxPlotOutlier::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BoxPlotOutlier::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoxPlotOutlier::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.BoxPlotOutlier)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.category_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.value_) -
      reinterpret_cast<char*>(&_impl_.category_index_)) + sizeof(_impl_.value_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoxPlotOutlier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 category_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.category_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoxPlotOutlier::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.BoxPlotOutlier)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 category_index = 1;
  if (this->_internal_category_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_category_index(), target);
  }

  // double value = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.BoxPlotOutlier)
  return target;
}

size_t BoxPlotOutlier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.BoxPlotOutlier)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 category_index = 1;
  if (this->_internal_category_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_category_index());
  }

  // double value = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = this->_internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoxPlotOutlier::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoxPlotOutlier::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoxPlotOutlier::GetClassData() const { return &_class_data_; }


void BoxPlotOutlier::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoxPlotOutlier*>(&to_msg);
  auto& from = static_cast<const BoxPlotOutlier&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.BoxPlotOutlier)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_category_index() != 0) {
    _this->_internal_set_category_index(from._internal_category_index());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_value = from._internal_value();
  uint64_t raw_value;
  memcpy(&raw_value, &tmp_value, sizeof(tmp_value));
  if (raw_value != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoxPlotOutlier::CopyFrom(const BoxPlotOutlier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.BoxPlotOutlier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoxPlotOutlier::IsInitialized() const {
  return true;
}

void BoxPlotOutlier::InternalSwap(BoxPlotOutlier* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BoxPlotOutlier, _impl_.value_)
      + sizeof(BoxPlotOutlier::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(BoxPlotOutlier, _impl_.category_index_)>(
          reinterpret_cast<char*>(&_impl_.category_index_),
          reinterpret_cast<char*>(&other->_impl_.category_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BoxPlotOutlier::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[12]);
}

// ===================================================================

class BoxPlotDataPointDef::_Internal {
 public:
};

BoxPlotDataPointDef::BoxPlotDataPointDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.BoxPlotDataPointDef)
}
BoxPlotDataPointDef::BoxPlotDataPointDef(const BoxPlotDataPointDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoxPlotDataPointDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.outliers_){from._impl_.outliers_}
    , decltype(_impl_.points_){from._impl_.points_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:epoch_proto.BoxPlotDataPointDef)
}

inline void BoxPlotDataPointDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.outliers_){arena}
    , decltype(_impl_.points_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BoxPlotDataPointDef::~BoxPlotDataPointDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.BoxPlotDataPointDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoxPlotDataPointDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.outliers_.~RepeatedPtrField();
  _impl_.points_.~RepeatedPtrField();
}

void BoxPlotDataPointDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoxPlotDataPointDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.BoxPlotDataPointDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.outliers_.Clear();
  _impl_.points_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoxPlotDataPointDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .epoch_proto.BoxPlotOutlier outliers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outliers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.BoxPlotDataPoint points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoxPlotDataPointDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.BoxPlotDataPointDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .epoch_proto.BoxPlotOutlier outliers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outliers_size()); i < n; i++) {
    const auto& repfield = this->_internal_outliers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.BoxPlotDataPoint points = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.BoxPlotDataPointDef)
  return target;
}

size_t BoxPlotDataPointDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.BoxPlotDataPointDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.BoxPlotOutlier outliers = 1;
  total_size += 1UL * this->_internal_outliers_size();
  for (const auto& msg : this->_impl_.outliers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .epoch_proto.BoxPlotDataPoint points = 2;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoxPlotDataPointDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoxPlotDataPointDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoxPlotDataPointDef::GetClassData() const { return &_class_data_; }


void BoxPlotDataPointDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoxPlotDataPointDef*>(&to_msg);
  auto& from = static_cast<const BoxPlotDataPointDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.BoxPlotDataPointDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.outliers_.MergeFrom(from._impl_.outliers_);
  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoxPlotDataPointDef::CopyFrom(const BoxPlotDataPointDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.BoxPlotDataPointDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoxPlotDataPointDef::IsInitialized() const {
  return true;
}

void BoxPlotDataPointDef::InternalSwap(BoxPlotDataPointDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.outliers_.InternalSwap(&other->_impl_.outliers_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BoxPlotDataPointDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[13]);
}

// ===================================================================

class BoxPlotDef::_Internal {
 public:
  static const ::epoch_proto::ChartDef& chart_def(const BoxPlotDef* msg);
  static const ::epoch_proto::BoxPlotDataPointDef& data(const BoxPlotDef* msg);
};

const ::epoch_proto::ChartDef&
BoxPlotDef::_Internal::chart_def(const BoxPlotDef* msg) {
  return *msg->_impl_.chart_def_;
}
const ::epoch_proto::BoxPlotDataPointDef&
BoxPlotDef::_Internal::data(const BoxPlotDef* msg) {
  return *msg->_impl_.data_;
}
BoxPlotDef::BoxPlotDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.BoxPlotDef)
}
BoxPlotDef::BoxPlotDef(const BoxPlotDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoxPlotDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chart_def()) {
    _this->_impl_.chart_def_ = new ::epoch_proto::ChartDef(*from._impl_.chart_def_);
  }
  if (from._internal_has_data()) {
    _this->_impl_.data_ = new ::epoch_proto::BoxPlotDataPointDef(*from._impl_.data_);
  }
  // @@protoc_insertion_point(copy_constructor:epoch_proto.BoxPlotDef)
}

inline void BoxPlotDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.chart_def_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BoxPlotDef::~BoxPlotDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.BoxPlotDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoxPlotDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.chart_def_;
  if (this != internal_default_instance()) delete _impl_.data_;
}

void BoxPlotDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoxPlotDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.BoxPlotDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoxPlotDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.ChartDef chart_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chart_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.BoxPlotDataPointDef data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoxPlotDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.BoxPlotDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chart_def(this),
        _Internal::chart_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.BoxPlotDataPointDef data = 2;
  if (this->_internal_has_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.BoxPlotDef)
  return target;
}

size_t BoxPlotDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.BoxPlotDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chart_def_);
  }

  // .epoch_proto.BoxPlotDataPointDef data = 2;
  if (this->_internal_has_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.data_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoxPlotDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoxPlotDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoxPlotDef::GetClassData() const { return &_class_data_; }


void BoxPlotDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoxPlotDef*>(&to_msg);
  auto& from = static_cast<const BoxPlotDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.BoxPlotDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_chart_def()) {
    _this->_internal_mutable_chart_def()->::epoch_proto::ChartDef::MergeFrom(
        from._internal_chart_def());
  }
  if (from._internal_has_data()) {
    _this->_internal_mutable_data()->::epoch_proto::BoxPlotDataPointDef::MergeFrom(
        from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoxPlotDef::CopyFrom(const BoxPlotDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.BoxPlotDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoxPlotDef::IsInitialized() const {
  return true;
}

void BoxPlotDef::InternalSwap(BoxPlotDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BoxPlotDef, _impl_.data_)
      + sizeof(BoxPlotDef::_impl_.data_)
      - PROTOBUF_FIELD_OFFSET(BoxPlotDef, _impl_.chart_def_)>(
          reinterpret_cast<char*>(&_impl_.chart_def_),
          reinterpret_cast<char*>(&other->_impl_.chart_def_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BoxPlotDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[14]);
}

// ===================================================================

class XRangePoint::_Internal {
 public:
};

XRangePoint::XRangePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.XRangePoint)
}
XRangePoint::XRangePoint(const XRangePoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  XRangePoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.x2_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.is_long_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_long_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.is_long_));
  // @@protoc_insertion_point(copy_constructor:epoch_proto.XRangePoint)
}

inline void XRangePoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){int64_t{0}}
    , decltype(_impl_.x2_){int64_t{0}}
    , decltype(_impl_.y_){uint64_t{0u}}
    , decltype(_impl_.is_long_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

XRangePoint::~XRangePoint() {
  // @@protoc_insertion_point(destructor:epoch_proto.XRangePoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void XRangePoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void XRangePoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void XRangePoint::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.XRangePoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_long_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.is_long_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* XRangePoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 x2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.x2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_long = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.is_long_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* XRangePoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.XRangePoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_x(), target);
  }

  // int64 x2 = 2;
  if (this->_internal_x2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_x2(), target);
  }

  // uint64 y = 3;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_y(), target);
  }

  // bool is_long = 4;
  if (this->_internal_is_long() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_long(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.XRangePoint)
  return target;
}

size_t XRangePoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.XRangePoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_x());
  }

  // int64 x2 = 2;
  if (this->_internal_x2() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_x2());
  }

  // uint64 y = 3;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_y());
  }

  // bool is_long = 4;
  if (this->_internal_is_long() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData XRangePoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    XRangePoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*XRangePoint::GetClassData() const { return &_class_data_; }


void XRangePoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<XRangePoint*>(&to_msg);
  auto& from = static_cast<const XRangePoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.XRangePoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_x2() != 0) {
    _this->_internal_set_x2(from._internal_x2());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  if (from._internal_is_long() != 0) {
    _this->_internal_set_is_long(from._internal_is_long());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void XRangePoint::CopyFrom(const XRangePoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.XRangePoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XRangePoint::IsInitialized() const {
  return true;
}

void XRangePoint::InternalSwap(XRangePoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(XRangePoint, _impl_.is_long_)
      + sizeof(XRangePoint::_impl_.is_long_)
      - PROTOBUF_FIELD_OFFSET(XRangePoint, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata XRangePoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[15]);
}

// ===================================================================

class XRangeDef::_Internal {
 public:
  static const ::epoch_proto::ChartDef& chart_def(const XRangeDef* msg);
};

const ::epoch_proto::ChartDef&
XRangeDef::_Internal::chart_def(const XRangeDef* msg) {
  return *msg->_impl_.chart_def_;
}
XRangeDef::XRangeDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.XRangeDef)
}
XRangeDef::XRangeDef(const XRangeDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  XRangeDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.categories_){from._impl_.categories_}
    , decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.chart_def_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chart_def()) {
    _this->_impl_.chart_def_ = new ::epoch_proto::ChartDef(*from._impl_.chart_def_);
  }
  // @@protoc_insertion_point(copy_constructor:epoch_proto.XRangeDef)
}

inline void XRangeDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.categories_){arena}
    , decltype(_impl_.points_){arena}
    , decltype(_impl_.chart_def_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

XRangeDef::~XRangeDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.XRangeDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void XRangeDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.categories_.~RepeatedPtrField();
  _impl_.points_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.chart_def_;
}

void XRangeDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void XRangeDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.XRangeDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.categories_.Clear();
  _impl_.points_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* XRangeDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.ChartDef chart_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chart_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string categories = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_categories();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.XRangeDef.categories"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.XRangePoint points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* XRangeDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.XRangeDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chart_def(this),
        _Internal::chart_def(this).GetCachedSize(), target, stream);
  }

  // repeated string categories = 2;
  for (int i = 0, n = this->_internal_categories_size(); i < n; i++) {
    const auto& s = this->_internal_categories(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.XRangeDef.categories");
    target = stream->WriteString(2, s, target);
  }

  // repeated .epoch_proto.XRangePoint points = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.XRangeDef)
  return target;
}

size_t XRangeDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.XRangeDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string categories = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.categories_.size());
  for (int i = 0, n = _impl_.categories_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.categories_.Get(i));
  }

  // repeated .epoch_proto.XRangePoint points = 3;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chart_def_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData XRangeDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    XRangeDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*XRangeDef::GetClassData() const { return &_class_data_; }


void XRangeDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<XRangeDef*>(&to_msg);
  auto& from = static_cast<const XRangeDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.XRangeDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.categories_.MergeFrom(from._impl_.categories_);
  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  if (from._internal_has_chart_def()) {
    _this->_internal_mutable_chart_def()->::epoch_proto::ChartDef::MergeFrom(
        from._internal_chart_def());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void XRangeDef::CopyFrom(const XRangeDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.XRangeDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XRangeDef::IsInitialized() const {
  return true;
}

void XRangeDef::InternalSwap(XRangeDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.categories_.InternalSwap(&other->_impl_.categories_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  swap(_impl_.chart_def_, other->_impl_.chart_def_);
}

::PROTOBUF_NAMESPACE_ID::Metadata XRangeDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[16]);
}

// ===================================================================

class PieData::_Internal {
 public:
};

PieData::PieData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.PieData)
}
PieData::PieData(const PieData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PieData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.y_ = from._impl_.y_;
  // @@protoc_insertion_point(copy_constructor:epoch_proto.PieData)
}

inline void PieData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PieData::~PieData() {
  // @@protoc_insertion_point(destructor:epoch_proto.PieData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PieData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void PieData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PieData::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.PieData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.y_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PieData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.PieData.name"));
        } else
          goto handle_unusual;
        continue;
      // double y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PieData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.PieData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.PieData.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.PieData)
  return target;
}

size_t PieData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.PieData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // double y = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PieData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PieData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PieData::GetClassData() const { return &_class_data_; }


void PieData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PieData*>(&to_msg);
  auto& from = static_cast<const PieData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.PieData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PieData::CopyFrom(const PieData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.PieData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PieData::IsInitialized() const {
  return true;
}

void PieData::InternalSwap(PieData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.y_, other->_impl_.y_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PieData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[17]);
}

// ===================================================================

class PieDataDef::_Internal {
 public:
  using HasBits = decltype(std::declval<PieDataDef>()._impl_._has_bits_);
  static void set_has_inner_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PieDataDef::PieDataDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.PieDataDef)
}
PieDataDef::PieDataDef(const PieDataDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PieDataDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.inner_size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_size().empty()) {
    _this->_impl_.size_.Set(from._internal_size(), 
      _this->GetArenaForAllocation());
  }
  _impl_.inner_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_inner_size()) {
    _this->_impl_.inner_size_.Set(from._internal_inner_size(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:epoch_proto.PieDataDef)
}

inline void PieDataDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.points_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.inner_size_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.inner_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PieDataDef::~PieDataDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.PieDataDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PieDataDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.size_.Destroy();
  _impl_.inner_size_.Destroy();
}

void PieDataDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PieDataDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.PieDataDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.size_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.inner_size_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PieDataDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.PieDataDef.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.PieData points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.PieDataDef.size"));
        } else
          goto handle_unusual;
        continue;
      // optional string inner_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_inner_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "epoch_proto.PieDataDef.inner_size"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PieDataDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.PieDataDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.PieDataDef.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .epoch_proto.PieData points = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string size = 3;
  if (!this->_internal_size().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_size().data(), static_cast<int>(this->_internal_size().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.PieDataDef.size");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_size(), target);
  }

  // optional string inner_size = 4;
  if (_internal_has_inner_size()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_inner_size().data(), static_cast<int>(this->_internal_inner_size().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "epoch_proto.PieDataDef.inner_size");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_inner_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.PieDataDef)
  return target;
}

size_t PieDataDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.PieDataDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.PieData points = 2;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string size = 3;
  if (!this->_internal_size().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_size());
  }

  // optional string inner_size = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_inner_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PieDataDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PieDataDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PieDataDef::GetClassData() const { return &_class_data_; }


void PieDataDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PieDataDef*>(&to_msg);
  auto& from = static_cast<const PieDataDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.PieDataDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_size().empty()) {
    _this->_internal_set_size(from._internal_size());
  }
  if (from._internal_has_inner_size()) {
    _this->_internal_set_inner_size(from._internal_inner_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PieDataDef::CopyFrom(const PieDataDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.PieDataDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PieDataDef::IsInitialized() const {
  return true;
}

void PieDataDef::InternalSwap(PieDataDef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.size_, lhs_arena,
      &other->_impl_.size_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.inner_size_, lhs_arena,
      &other->_impl_.inner_size_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PieDataDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[18]);
}

// ===================================================================

class PieDef::_Internal {
 public:
  static const ::epoch_proto::ChartDef& chart_def(const PieDef* msg);
};

const ::epoch_proto::ChartDef&
PieDef::_Internal::chart_def(const PieDef* msg) {
  return *msg->_impl_.chart_def_;
}
PieDef::PieDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.PieDef)
}
PieDef::PieDef(const PieDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PieDef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){from._impl_.data_}
    , decltype(_impl_.chart_def_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chart_def()) {
    _this->_impl_.chart_def_ = new ::epoch_proto::ChartDef(*from._impl_.chart_def_);
  }
  // @@protoc_insertion_point(copy_constructor:epoch_proto.PieDef)
}

inline void PieDef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){arena}
    , decltype(_impl_.chart_def_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PieDef::~PieDef() {
  // @@protoc_insertion_point(destructor:epoch_proto.PieDef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PieDef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.chart_def_;
}

void PieDef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PieDef::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.PieDef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.chart_def_ != nullptr) {
    delete _impl_.chart_def_;
  }
  _impl_.chart_def_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PieDef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.ChartDef chart_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chart_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .epoch_proto.PieDataDef data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PieDef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.PieDef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chart_def(this),
        _Internal::chart_def(this).GetCachedSize(), target, stream);
  }

  // repeated .epoch_proto.PieDataDef data = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.PieDef)
  return target;
}

size_t PieDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.PieDef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .epoch_proto.PieDataDef data = 2;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->_impl_.data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .epoch_proto.ChartDef chart_def = 1;
  if (this->_internal_has_chart_def()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chart_def_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PieDef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PieDef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PieDef::GetClassData() const { return &_class_data_; }


void PieDef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PieDef*>(&to_msg);
  auto& from = static_cast<const PieDef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.PieDef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  if (from._internal_has_chart_def()) {
    _this->_internal_mutable_chart_def()->::epoch_proto::ChartDef::MergeFrom(
        from._internal_chart_def());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PieDef::CopyFrom(const PieDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.PieDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PieDef::IsInitialized() const {
  return true;
}

void PieDef::InternalSwap(PieDef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  swap(_impl_.chart_def_, other->_impl_.chart_def_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PieDef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[19]);
}

// ===================================================================

class Chart::_Internal {
 public:
  static const ::epoch_proto::LinesDef& lines_def(const Chart* msg);
  static const ::epoch_proto::HeatMapDef& heat_map_def(const Chart* msg);
  static const ::epoch_proto::BarDef& bar_def(const Chart* msg);
  static const ::epoch_proto::HistogramDef& histogram_def(const Chart* msg);
  static const ::epoch_proto::BoxPlotDef& box_plot_def(const Chart* msg);
  static const ::epoch_proto::XRangeDef& x_range_def(const Chart* msg);
  static const ::epoch_proto::PieDef& pie_def(const Chart* msg);
};

const ::epoch_proto::LinesDef&
Chart::_Internal::lines_def(const Chart* msg) {
  return *msg->_impl_.chart_type_.lines_def_;
}
const ::epoch_proto::HeatMapDef&
Chart::_Internal::heat_map_def(const Chart* msg) {
  return *msg->_impl_.chart_type_.heat_map_def_;
}
const ::epoch_proto::BarDef&
Chart::_Internal::bar_def(const Chart* msg) {
  return *msg->_impl_.chart_type_.bar_def_;
}
const ::epoch_proto::HistogramDef&
Chart::_Internal::histogram_def(const Chart* msg) {
  return *msg->_impl_.chart_type_.histogram_def_;
}
const ::epoch_proto::BoxPlotDef&
Chart::_Internal::box_plot_def(const Chart* msg) {
  return *msg->_impl_.chart_type_.box_plot_def_;
}
const ::epoch_proto::XRangeDef&
Chart::_Internal::x_range_def(const Chart* msg) {
  return *msg->_impl_.chart_type_.x_range_def_;
}
const ::epoch_proto::PieDef&
Chart::_Internal::pie_def(const Chart* msg) {
  return *msg->_impl_.chart_type_.pie_def_;
}
void Chart::set_allocated_lines_def(::epoch_proto::LinesDef* lines_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_chart_type();
  if (lines_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lines_def);
    if (message_arena != submessage_arena) {
      lines_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lines_def, submessage_arena);
    }
    set_has_lines_def();
    _impl_.chart_type_.lines_def_ = lines_def;
  }
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Chart.lines_def)
}
void Chart::set_allocated_heat_map_def(::epoch_proto::HeatMapDef* heat_map_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_chart_type();
  if (heat_map_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heat_map_def);
    if (message_arena != submessage_arena) {
      heat_map_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heat_map_def, submessage_arena);
    }
    set_has_heat_map_def();
    _impl_.chart_type_.heat_map_def_ = heat_map_def;
  }
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Chart.heat_map_def)
}
void Chart::set_allocated_bar_def(::epoch_proto::BarDef* bar_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_chart_type();
  if (bar_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bar_def);
    if (message_arena != submessage_arena) {
      bar_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bar_def, submessage_arena);
    }
    set_has_bar_def();
    _impl_.chart_type_.bar_def_ = bar_def;
  }
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Chart.bar_def)
}
void Chart::set_allocated_histogram_def(::epoch_proto::HistogramDef* histogram_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_chart_type();
  if (histogram_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(histogram_def);
    if (message_arena != submessage_arena) {
      histogram_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, histogram_def, submessage_arena);
    }
    set_has_histogram_def();
    _impl_.chart_type_.histogram_def_ = histogram_def;
  }
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Chart.histogram_def)
}
void Chart::set_allocated_box_plot_def(::epoch_proto::BoxPlotDef* box_plot_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_chart_type();
  if (box_plot_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(box_plot_def);
    if (message_arena != submessage_arena) {
      box_plot_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box_plot_def, submessage_arena);
    }
    set_has_box_plot_def();
    _impl_.chart_type_.box_plot_def_ = box_plot_def;
  }
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Chart.box_plot_def)
}
void Chart::set_allocated_x_range_def(::epoch_proto::XRangeDef* x_range_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_chart_type();
  if (x_range_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(x_range_def);
    if (message_arena != submessage_arena) {
      x_range_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x_range_def, submessage_arena);
    }
    set_has_x_range_def();
    _impl_.chart_type_.x_range_def_ = x_range_def;
  }
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Chart.x_range_def)
}
void Chart::set_allocated_pie_def(::epoch_proto::PieDef* pie_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_chart_type();
  if (pie_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pie_def);
    if (message_arena != submessage_arena) {
      pie_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pie_def, submessage_arena);
    }
    set_has_pie_def();
    _impl_.chart_type_.pie_def_ = pie_def;
  }
  // @@protoc_insertion_point(field_set_allocated:epoch_proto.Chart.pie_def)
}
Chart::Chart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:epoch_proto.Chart)
}
Chart::Chart(const Chart& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Chart* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.chart_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_chart_type();
  switch (from.chart_type_case()) {
    case kLinesDef: {
      _this->_internal_mutable_lines_def()->::epoch_proto::LinesDef::MergeFrom(
          from._internal_lines_def());
      break;
    }
    case kHeatMapDef: {
      _this->_internal_mutable_heat_map_def()->::epoch_proto::HeatMapDef::MergeFrom(
          from._internal_heat_map_def());
      break;
    }
    case kBarDef: {
      _this->_internal_mutable_bar_def()->::epoch_proto::BarDef::MergeFrom(
          from._internal_bar_def());
      break;
    }
    case kHistogramDef: {
      _this->_internal_mutable_histogram_def()->::epoch_proto::HistogramDef::MergeFrom(
          from._internal_histogram_def());
      break;
    }
    case kBoxPlotDef: {
      _this->_internal_mutable_box_plot_def()->::epoch_proto::BoxPlotDef::MergeFrom(
          from._internal_box_plot_def());
      break;
    }
    case kXRangeDef: {
      _this->_internal_mutable_x_range_def()->::epoch_proto::XRangeDef::MergeFrom(
          from._internal_x_range_def());
      break;
    }
    case kPieDef: {
      _this->_internal_mutable_pie_def()->::epoch_proto::PieDef::MergeFrom(
          from._internal_pie_def());
      break;
    }
    case CHART_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:epoch_proto.Chart)
}

inline void Chart::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.chart_type_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_chart_type();
}

Chart::~Chart() {
  // @@protoc_insertion_point(destructor:epoch_proto.Chart)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Chart::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_chart_type()) {
    clear_chart_type();
  }
}

void Chart::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Chart::clear_chart_type() {
// @@protoc_insertion_point(one_of_clear_start:epoch_proto.Chart)
  switch (chart_type_case()) {
    case kLinesDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.chart_type_.lines_def_;
      }
      break;
    }
    case kHeatMapDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.chart_type_.heat_map_def_;
      }
      break;
    }
    case kBarDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.chart_type_.bar_def_;
      }
      break;
    }
    case kHistogramDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.chart_type_.histogram_def_;
      }
      break;
    }
    case kBoxPlotDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.chart_type_.box_plot_def_;
      }
      break;
    }
    case kXRangeDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.chart_type_.x_range_def_;
      }
      break;
    }
    case kPieDef: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.chart_type_.pie_def_;
      }
      break;
    }
    case CHART_TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CHART_TYPE_NOT_SET;
}


void Chart::Clear() {
// @@protoc_insertion_point(message_clear_start:epoch_proto.Chart)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_chart_type();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Chart::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .epoch_proto.LinesDef lines_def = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_lines_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.HeatMapDef heat_map_def = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_heat_map_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.BarDef bar_def = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bar_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.HistogramDef histogram_def = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_histogram_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.BoxPlotDef box_plot_def = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_box_plot_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.XRangeDef x_range_def = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_x_range_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .epoch_proto.PieDef pie_def = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_pie_def(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Chart::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:epoch_proto.Chart)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .epoch_proto.LinesDef lines_def = 1;
  if (_internal_has_lines_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::lines_def(this),
        _Internal::lines_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.HeatMapDef heat_map_def = 2;
  if (_internal_has_heat_map_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::heat_map_def(this),
        _Internal::heat_map_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.BarDef bar_def = 3;
  if (_internal_has_bar_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::bar_def(this),
        _Internal::bar_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.HistogramDef histogram_def = 4;
  if (_internal_has_histogram_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::histogram_def(this),
        _Internal::histogram_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.BoxPlotDef box_plot_def = 5;
  if (_internal_has_box_plot_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::box_plot_def(this),
        _Internal::box_plot_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.XRangeDef x_range_def = 6;
  if (_internal_has_x_range_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::x_range_def(this),
        _Internal::x_range_def(this).GetCachedSize(), target, stream);
  }

  // .epoch_proto.PieDef pie_def = 7;
  if (_internal_has_pie_def()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::pie_def(this),
        _Internal::pie_def(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:epoch_proto.Chart)
  return target;
}

size_t Chart::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:epoch_proto.Chart)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (chart_type_case()) {
    // .epoch_proto.LinesDef lines_def = 1;
    case kLinesDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chart_type_.lines_def_);
      break;
    }
    // .epoch_proto.HeatMapDef heat_map_def = 2;
    case kHeatMapDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chart_type_.heat_map_def_);
      break;
    }
    // .epoch_proto.BarDef bar_def = 3;
    case kBarDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chart_type_.bar_def_);
      break;
    }
    // .epoch_proto.HistogramDef histogram_def = 4;
    case kHistogramDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chart_type_.histogram_def_);
      break;
    }
    // .epoch_proto.BoxPlotDef box_plot_def = 5;
    case kBoxPlotDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chart_type_.box_plot_def_);
      break;
    }
    // .epoch_proto.XRangeDef x_range_def = 6;
    case kXRangeDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chart_type_.x_range_def_);
      break;
    }
    // .epoch_proto.PieDef pie_def = 7;
    case kPieDef: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chart_type_.pie_def_);
      break;
    }
    case CHART_TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Chart::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Chart::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Chart::GetClassData() const { return &_class_data_; }


void Chart::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Chart*>(&to_msg);
  auto& from = static_cast<const Chart&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:epoch_proto.Chart)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.chart_type_case()) {
    case kLinesDef: {
      _this->_internal_mutable_lines_def()->::epoch_proto::LinesDef::MergeFrom(
          from._internal_lines_def());
      break;
    }
    case kHeatMapDef: {
      _this->_internal_mutable_heat_map_def()->::epoch_proto::HeatMapDef::MergeFrom(
          from._internal_heat_map_def());
      break;
    }
    case kBarDef: {
      _this->_internal_mutable_bar_def()->::epoch_proto::BarDef::MergeFrom(
          from._internal_bar_def());
      break;
    }
    case kHistogramDef: {
      _this->_internal_mutable_histogram_def()->::epoch_proto::HistogramDef::MergeFrom(
          from._internal_histogram_def());
      break;
    }
    case kBoxPlotDef: {
      _this->_internal_mutable_box_plot_def()->::epoch_proto::BoxPlotDef::MergeFrom(
          from._internal_box_plot_def());
      break;
    }
    case kXRangeDef: {
      _this->_internal_mutable_x_range_def()->::epoch_proto::XRangeDef::MergeFrom(
          from._internal_x_range_def());
      break;
    }
    case kPieDef: {
      _this->_internal_mutable_pie_def()->::epoch_proto::PieDef::MergeFrom(
          from._internal_pie_def());
      break;
    }
    case CHART_TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Chart::CopyFrom(const Chart& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:epoch_proto.Chart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chart::IsInitialized() const {
  return true;
}

void Chart::InternalSwap(Chart* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.chart_type_, other->_impl_.chart_type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Chart::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_chart_5fdef_2eproto_getter, &descriptor_table_chart_5fdef_2eproto_once,
      file_level_metadata_chart_5fdef_2eproto[20]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace epoch_proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::epoch_proto::AxisDef*
Arena::CreateMaybeMessage< ::epoch_proto::AxisDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::AxisDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::ChartDef*
Arena::CreateMaybeMessage< ::epoch_proto::ChartDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::ChartDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::StraightLineDef*
Arena::CreateMaybeMessage< ::epoch_proto::StraightLineDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::StraightLineDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::Band*
Arena::CreateMaybeMessage< ::epoch_proto::Band >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::Band >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::Point*
Arena::CreateMaybeMessage< ::epoch_proto::Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::Point >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::Line*
Arena::CreateMaybeMessage< ::epoch_proto::Line >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::Line >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::LinesDef*
Arena::CreateMaybeMessage< ::epoch_proto::LinesDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::LinesDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::HeatMapPoint*
Arena::CreateMaybeMessage< ::epoch_proto::HeatMapPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::HeatMapPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::HeatMapDef*
Arena::CreateMaybeMessage< ::epoch_proto::HeatMapDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::HeatMapDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::BarDef*
Arena::CreateMaybeMessage< ::epoch_proto::BarDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::BarDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::HistogramDef*
Arena::CreateMaybeMessage< ::epoch_proto::HistogramDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::HistogramDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::BoxPlotDataPoint*
Arena::CreateMaybeMessage< ::epoch_proto::BoxPlotDataPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::BoxPlotDataPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::BoxPlotOutlier*
Arena::CreateMaybeMessage< ::epoch_proto::BoxPlotOutlier >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::BoxPlotOutlier >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::BoxPlotDataPointDef*
Arena::CreateMaybeMessage< ::epoch_proto::BoxPlotDataPointDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::BoxPlotDataPointDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::BoxPlotDef*
Arena::CreateMaybeMessage< ::epoch_proto::BoxPlotDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::BoxPlotDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::XRangePoint*
Arena::CreateMaybeMessage< ::epoch_proto::XRangePoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::XRangePoint >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::XRangeDef*
Arena::CreateMaybeMessage< ::epoch_proto::XRangeDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::XRangeDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::PieData*
Arena::CreateMaybeMessage< ::epoch_proto::PieData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::PieData >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::PieDataDef*
Arena::CreateMaybeMessage< ::epoch_proto::PieDataDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::PieDataDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::PieDef*
Arena::CreateMaybeMessage< ::epoch_proto::PieDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::PieDef >(arena);
}
template<> PROTOBUF_NOINLINE ::epoch_proto::Chart*
Arena::CreateMaybeMessage< ::epoch_proto::Chart >(Arena* arena) {
  return Arena::CreateMessageInternal< ::epoch_proto::Chart >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
